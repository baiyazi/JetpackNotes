{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 文档阅读地址：https://baiyazi.github.io/JetpackNotes 【Android Jetpack】LifeCycle 数据存储 DataStore 视图绑定 数据绑定 【Android Jetpack】Room——基本使用 【Android Jetpack】Livedata 【Android Jetpack】Room+ViewModel+LiveData 【Android Jetpack】Room——其余 【Android Jetpack】Room——多表之间的关系 【AndroidJetpack】Navigation——基础入门.md 【AndroidJetpack】Navigation——条件导航 【AndroidJetpack】Navigation——DeepLink.md Gitbook安装 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:17:16 "},"Jetpack 基础认知.html":{"url":"Jetpack 基础认知.html","title":"Jetpack 基础认知","keywords":"","body":" 【Android Jetpack】LifeCycle 数据存储 视图绑定 DataStore 数据绑定 【Android Jetpack】Room——基本使用 【Android Jetpack】Livedata 【Android Jetpack】Room+ViewModel+LiveData 【Android Jetpack】Room——其余 【AndroidJetpack】Room——对象之间的关系 【AndroidJetpack】Navigation——基础入门 【AndroidJetpack】Navigation——条件导航 【AndroidJetpack】Navigation——DeepLink Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-03 12:45:02 "},"Jetpack之LifeCycle.html":{"url":"Jetpack之LifeCycle.html","title":"【Android Jetpack】LifeCycle","keywords":"","body":"[TOC] 1. 说明 LifeCycle它持有组件的生命周期状态信息，主要用于Activity、Fragment、Service和Application的生命周期管理，其他类可以观察到这些状态，进而有利于代码的解耦。而且在配置更改后可以轻松避免内存泄漏，以及将数据加载到界面中。 比如在Activity 生命周期的状态和事件： 2. Lifecycle 在Lifecycle中存在两类角色： 具有生命周期的组件，比如Activity、Fragment、Service 等任何具有生命周期的组件，通常被称为LifecycleOwner，也即是被观察者。 LifecycleObserver，即观察者，需要感知生命周期方法。 很明显，也就是观察者模式。由于在上述组件中已经实现了LifecycleObserver接口，比如在Activity中： public class ComponentActivity extends androidx.core.app.ComponentActivity implements ContextAware, LifecycleOwner, ... 并实现了其getLifecycle方法，故而在观察者模式中被观察者已经由系统实现，我们所需要做的也就是实现观察者类，也即是自定义类，实现LifecycleObserver接口，然后设置观察即可。 2.1 LifecycleObserver 而该接口又只是一个空接口，即仅用作标识： public interface LifecycleObserver { } 2.2 LifecycleOwner LifecycleOwner 是一个接口，用来表示类具有Lifecycle。其声明如下： public interface LifecycleOwner { @NonNull Lifecycle getLifecycle(); } 可以看见只有一个方法，也就是getLifecycle()， 可以通过调用Lifecycle类的addObserver()方法并传递观察器的实例来添加观察器，比如下面的代码： class MyObserver : DefaultLifecycleObserver { override fun onResume(owner: LifecycleOwner) { connect() } override fun onPause(owner: LifecycleOwner) { disconnect() } } myLifecycleOwner.getLifecycle().addObserver(MyObserver()) 3. 案例 比如下面的案例： 3.1 案例一：使用LifeCycle解耦页面组件 学习视频地址：LifeCycle 不使用LifeCycle的时候，通过Chronometer计时器来做一个简单的计时操作，满足下面条件： 当Activity可见的时候，继续计时； 当Activity不可见的时候，且还没有被Destory的时候，就暂停当前计时； 3.1.1 借助生命周期方法 class MainActivity : AppCompatActivity() { // 继承自TextView的一个计时器类 private lateinit var chronometer: Chronometer override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) chronometer = findViewById(R.id.chronometer) } private var elapsedtime = 0L // 可见 override fun onResume() { super.onResume() // 设置计时器的起始时间为“当前”系统时间 // SystemClock.elapsedRealtime() 从设备开机到现在的时间 chronometer.base = SystemClock.elapsedRealtime() - elapsedtime chronometer.start() } // 不可见 override fun onStop() { super.onStop() elapsedtime = SystemClock.elapsedRealtime() - chronometer.base chronometer.stop() } } 上面设置chronometer.base，主要是用于设置计时器的“当前起始时间”，主要是为了确保暂停后开始的基准时间可以略过中间暂停事件，确保计时器在Activity可见后可以连续计时。但是，很显然，这样多余了很多额外的周期函数方法，使用比较麻烦。而使用LifeCycle可以对其进行最大程度简化。而且在组件化开发中，基本的原则就是：能不麻烦别人的事情就尽量自己做。需要暴露更少的方法来完成其功能。 3.1.2 借助LifeCycle 首先封装一下Chronometer这个类，声明其实现了LifecycleObserver接口： class MyChronometer: Chronometer, LifecycleObserver { constructor(context: Context?) : super(context) constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) private var elapsedtime = 0L @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun startChronometer(){ // 设置计时器的起始时间为“当前”系统时间 base = SystemClock.elapsedRealtime() - elapsedtime start() } @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stopChronometer(){ elapsedtime = SystemClock.elapsedRealtime() - base stop() } } 将前面案例中的代码添加到其中，并为其指定了对应的Lifecycle事件方法。对应的将xml中修改为我们自定义的MyChronometer类，然后调用： class MainActivity1 : AppCompatActivity() { // 继承自TextView的一个计时器类 private lateinit var chronometer: MyChronometer override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) chronometer = findViewById(R.id.chronometer) // 为Activity的lifecycle添加一个监听 lifecycle.addObserver(chronometer) } } 就可以看见一样满足要求的计时器。这两个案例做一个简单的对比，很明显第二种写法更加利于系统组件和普通组件的代码解耦。这里可以总结一下上面的使用流程： 自定义一个类，实现了LifecycleObserver接口； 在Activity或者Fragment中进行添加观察者，以监听对应的生命周期函数； 3.2 案例二：使用LifeCycleService解耦Service组件 视频地址：https://www.bilibili.com/video/BV1Ry4y1t7Tj?p=3&t=863.3 该案例以模拟获取GPS为案例，具体为在后台开启一个Service，然后在这个Service中注册观察者对象，在这个观察者对象中可以观察到Activity的onStart、onStop等事件。也就可以自动完成进入这个Activity就开始获取地理位置的更新，退出这个Activity就停止获取位置。 3.2.1. 基础版本 如果获取用户地理位置的功能没有独立封装为一个组件，那么我们如果需要考虑页面声明周期，那么就需要按照下面的形式，因为非自定义组件并不能主动感知声明周期的变化。 class LocationActivity: AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_location ) } override fun onResume() { super.onResume() // 开始获取用户地理位置 startGetLocation() } override fun onPause() { super.onPause() // 停止获取 stopGetLocation() } } 3.2.2. 使用Service 上面的第一种方式明显的缺点就是耦合度很高，所以为了减少耦合度，而又不影响对生命周期的监听，就可以使用LifeCycle来进行改写。故而我们可以自定义一个类，然后使用LifecycleObserver来标识这个类为LifeCycle的一个观察者类，在这个类中完成自定义控件，即具体功能。 class MyLocationObserver(context: Context): LifecycleObserver { private var mCtx : Context = context private lateinit var myLocationListener: MyLocationListener private lateinit var locationManager: LocationManager @OnLifecycleEvent(Lifecycle.Event.ON_START) private fun startGetLocation(){ Log.e(\"TAG\", \"startGetLocation: \") // 获取LocationManager locationManager = mCtx.getSystemService(Context.LOCATION_SERVICE) as LocationManager // 权限 if (ActivityCompat.checkSelfPermission( mCtx, Manifest.permission.ACCESS_FINE_LOCATION ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission( mCtx, Manifest.permission.ACCESS_COARSE_LOCATION ) != PackageManager.PERMISSION_GRANTED ) { return } // 添加监听 myLocationListener = MyLocationListener() locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3000, 2f, myLocationListener) } inner class MyLocationListener: LocationListener{ override fun onLocationChanged(location: Location) { Log.e(\"TAG\", \"onLocationChanged: ${ location }\" ) } } @OnLifecycleEvent(Lifecycle.Event.ON_STOP) private fun stopGetLocation(){ Log.e(\"TAG\", \"stopGetLocation: \", ) // 移除 locationManager.removeUpdates(myLocationListener) } } 当页面生命周期发生变化时，这些使用@OnLifecycleEvent标识过的方法便会被自动调用。那么在调用的时候，由于Activity或者Service均已经实现了被观察者LifecycleOwner的接口，故而这里直接调用实现这个接口的getLifecycle方法，得到Lifecycle对象，然后添加观察者： lifecycle.addObserver(MyLocationObserver(this)) 注意到，本小节的标题为使用Service，这里我们可以使用比较经典的写一个类继承自Service，根据自己所使用的启动方式，即startService或者bindService来复写对应的onStartCommand或者onBind方法。然后在Activity中进行startService或者bindService。比如： class MyService: LifecycleService() { private var _observer: MyLocationObserver = MyLocationObserver(this) init { lifecycle.addObserver(_observer) } override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Log.e(\"TAG\", \"onStartCommand: \") // 注册观察者 val myLocationObserver = MyLocationObserver(this) lifecycle.addObserver(myLocationObserver) return super.onStartCommand(intent, flags, startId) } override fun onDestroy() { super.onDestroy() lifecycle.removeObserver(_observer) } } 然后在主Activity中启动服务： class LocationActivity: AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_location ) // 启动服务 startService(Intent().apply { setClass(this@LocationActivity, MyService::class.java) }) } } 运行可以看见结果： 然后可以使用adb devices查看一下设备： 然后可以使用adb命令修改模拟位置： adb -s emulator-5554 emu geo fix 101.49612 41.24010 就可以发现日志进行了更新： 3.3. 案例三：监听应用程序的生命周期 在LifeCycle中提供了ProcessLifecycleOwner来实现监听应用程序的声明周期。同样的，这里还是自定义一个类，继承自LifecycleObserver： class MyApplicationObserver : LifecycleObserver { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) private fun onCreate() { Log.e(\"TAG\", \"application onCreate.\") } @OnLifecycleEvent(Lifecycle.Event.ON_START) private fun onStart() { Log.e(\"TAG\", \"application onStart.\") } @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) private fun onResume() { Log.e(\"TAG\", \"application onResume.\") } } 然后在Activity中使用： class LocationActivity: AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_location ) // 添加应用程序生命周期观察者对象 ProcessLifecycleOwner.get().lifecycle.addObserver(MyApplicationObserver()) } } 就可以监听到应用程序的生命周期变化。 ProcessLifecycleOwner是针对整个应用程序的监听，与Activity数量无关； Lifecycle.Event.ON_CREATE只会被调用一次，而Lifecycle.Event.ON_DESTROY永远不会被调用。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:27 "},"数据存储.html":{"url":"数据存储.html","title":"数据存储","keywords":"","body":" DataStore Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-03 12:41:10 "},"DataStore.html":{"url":"DataStore.html","title":"DataStore","keywords":"","body":"[TOC] 1. 前言 Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore使用Kotlin 协程和Flow 以异步、一致的事务方式存储数据。如果您当前在使用SharedPreferences存储数据，请考虑迁移到 DataStore。如果您需要支持大型或复杂数据集、部分更新或参照完整性，请考虑使用Room，而不是 DataStore。 2. 分类 DataStore 提供两种不同的实现：Preferences DataStore和 Proto DataStore。 Preferences DataStore使用键值对存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。DataStore 是基于 Flow 实现的，不会阻塞主线程。只支持Int,Long,Boolean,Float,String键值对数据，适合存储简单、小型的数据，并且不支持局部更新，如果修改了其中一个值，整个文件内容将会被重新序列化。 Proto DataStore将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。 Proto DataStore使用协议缓冲区来定义架构。使用协议缓冲区可持久保留强类型数据。与 XML 和其他类似的数据格式相比，协议缓冲区速度更快、规格更小、使用更简单，并且更清楚明了。虽然使用 Proto DataStore 需要学习新的序列化机制，但我们认为 Proto DataStore 有着强大的优势，值得学习。 2.1 Preferences DataStore 和SharedPreferences的区别 SharedPreferences 有一个看上去可以在界面线程中安全调用的同步API，但是该 API 实际上执行磁盘 I/O 操作。此外，apply()会阻断fsync()上的界面线程。每次有服务启动或停止以及每次 activity 在应用中的任何地方启动或停止时，系统都会触发待处理的fsync()调用。界面线程在apply()调度的待处理fsync()调用上会被阻断，这通常会导致ANR。 3. 实践 3.1 Preferences DataStore 3.1.1 依赖 // DataStore Preferences implementation(\"androidx.datastore:datastore-preferences:1.0.0\") // optional - RxJava2 support implementation(\"androidx.datastore:datastore-preferences-rxjava2:1.0.0\") // optional - RxJava3 support implementation(\"androidx.datastore:datastore-preferences-rxjava3:1.0.0\") 3.1.2 案例 下面案例来源于官网案例，地址：DataStore | Android 开发者 | Android Developers (google.cn)。 class MainActivity2 : AppCompatActivity() { // 创建一个DataStore，并申明在顶层以方便调用 private val Context.dataStore: DataStore by preferencesDataStore(name = \"settings\") // 声明一个int类型的key val EXAMPLE_COUNTER = intPreferencesKey(\"example_counter\") private val textView: TextView by lazy { findViewById(R.id.text) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } // 两个按钮的监听事件 fun buttonOnClick(view: View){ runBlocking { launch { when(view.id){ R.id.update -> { incrementCounter() } R.id.read -> { textView.text = getData().toString() } } } } } // 存储-自增1 suspend fun incrementCounter() { dataStore.edit { settings -> val currentCounterValue = settings[EXAMPLE_COUNTER] ?: 0 settings[EXAMPLE_COUNTER] = currentCounterValue + 1 } } // 获取当前值 suspend fun getData(): Int { return dataStore.data.map { settings -> settings[EXAMPLE_COUNTER] ?: 0 }.first() } } 结果： 3.1.3 最后 在前面提到了，这种类型的Preferences DataStore还支持的数据类型有：Long,Boolean,Float,String等，不妨看看对应的声明函数： longPreferencesKey() booleanPreferencesKey() floatPreferencesKey() stringSetPreferencesKey() 对应的，随便找一个方法，看下是如何实现的： @JvmName(\"longKey\") public fun longPreferencesKey(name: String): Preferences.Key = Preferences.Key(name) 也就是其实底层也还是使用Preferences.Key来指明类型。和SP类似数据内容也存储在本地磁盘data/data/packagename/中： 3.2 Proto DataStore 对于Preferences DataStore中的键只能为上述指定的类型，故而如果我们需要存储自定义对象的数据的时候，就显得力不从心了。故而在jetpack中提供了Proto DataStore。 3.2.1 依赖 引入datastore的依赖： implementation(\"androidx.datastore:datastore:1.0.0\") // optional - RxJava2 support implementation(\"androidx.datastore:datastore-rxjava2:1.0.0\") // optional - RxJava3 support implementation(\"androidx.datastore:datastore-rxjava3:1.0.0\") 为了使用 Proto DataStore，让协议缓冲区为我们的架构生成代码，我们需要对 build.gradle 文件进行一些更改： 3.2.1.1 添加协议缓冲区插件 plugins { ... id \"com.google.protobuf\" version \"0.8.12\" } 3.2.1.2 配置协议缓冲区 implementation \"com.google.protobuf:protobuf-javalite:3.10.0\" 在dependencies平级添加： protobuf { protoc { artifact = \"com.google.protobuf:protoc:3.10.0\" } // Generates the java Protobuf-lite code for the Protobufs in this project. See // https://github.com/google/protobuf-gradle-plugin#customizing-protobuf-compilation // for more information. generateProtoTasks { all().each { task -> task.builtins { java { option 'lite' } } } } } 3.2.2 定义架构 在app/src/main/目录下创建proto目录，然后创建一个xxx.proto文件： testDemo.proto文件内容： syntax = \"proto3\"; // 声明proto的版本 // 定义生成的类的包名 option java_package = \"com.weizu.jetpackdemo.proto\"; // 声明的是内部类MyProtoBean, 格式: 类型+字段名称+字段编号 message MyProtoBean { int32 _id = 1; string _name = 2; int32 _age = 3; bool _isMan = 4; } 至于更加详细的解释可以查阅：protobuf 语言指南以及使用 Proto DataStore (google.cn) 然后Build一下，就可以看到生成的文件： 打开文件可以看到在该文件中生成了配置中对应的message类，和对应的set/get方法： 至此环境配置完毕，接着开始简单使用。 3.2.3 简单使用 3.2.3.1 创建序列化器 我们需要实现序列化器，以告知 DataStore 如何读取和写入我们在 proto 文件中定义的数据类型。如果磁盘上没有数据，序列化器还会定义默认返回值。 object MyBeanSerializer: Serializer { override val defaultValue: TestDemo.MyProtoBean get() = TestDemo.MyProtoBean.getDefaultInstance() override suspend fun readFrom(input: InputStream): TestDemo.MyProtoBean { try { return TestDemo.MyProtoBean.parseFrom(input) } catch (exception: InvalidProtocolBufferException) { throw CorruptionException(\"Cannot read proto.\", exception) } } override suspend fun writeTo(t: TestDemo.MyProtoBean, output: OutputStream) { t.writeTo(output) } } 3.2.3.2 数据存储和读取 /** * @author 梦否 on 2022/3/28 * @blog https://mengfou.blog.csdn.net/ */ class MainActivity2 : AppCompatActivity() { private val textView: TextView by lazy { findViewById(R.id.text) } private val dataStore: DataStore by lazy { DataStoreFactory.create( produceFile = { applicationContext.dataStoreFile(\"user_prefs.pb\") }, serializer = MyBeanSerializer ) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } private var i = 0 // 按钮监听函数 fun buttonOnClick(view: View) { runBlocking { launch { when (view.id) { R.id.update -> { storeData(1 + i, 20 + i, true, \"张三${i}\") i++ } R.id.read -> { val first = readData().first() Log.e(\"TAG\", \"id：${first.id}\") Log.e(\"TAG\", \"age：${first.age}\") Log.e(\"TAG\", \"isMan：${first.isMan}\") Log.e(\"TAG\", \"name：${first.name}\") } } } } } // 读取数据时处理异常 private fun readData(): Flow { return dataStore.data .catch { exception -> // dataStore.data throws an IOException when an error is encountered when reading data if (exception is IOException) { Log.e(\"TAG\", \"Error reading sort order preferences.\", exception) emit(TestDemo.MyProtoBean.getDefaultInstance()) } else { throw exception } } } // 添加数据 private suspend fun storeData(id: Int, age: Int, isMan: Boolean, name: String) { dataStore.updateData { preferences -> preferences.toBuilder() .setAge(age) .setId(id) .setIsMan(isMan) .setName(name) .build() } } } 结果： 每次插入数据都会覆盖掉以前的数据，也就是在使用对象存储数据的时候，只能存储一条数据。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:27 "},"视图绑定.html":{"url":"视图绑定.html","title":"视图绑定","keywords":"","body":"[TOC] 1. 说明 视图绑定在大多数情况下，视图绑定会替代findViewById。而其实我们自己也可以定义一些注解，通过反射来完成对应的findViewById工作，比如Xutils和ButterKnife中都提供了这个功能。使用的时候比较简单，比如： @BindView(R.id.id_test) TextView tvTest; 但是上面两种使用注解及反射方式的查找控件实例的方式本质上都是调用findViewById自身。Google在Jetpack中推出视图绑定，首先看看二者有何不同。 1.1 与 findViewById 的区别 Null 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用@Nullable标记。 类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。 2. 使用 2.1 环境配置 首先检查一下Android Studio的版本，视图绑定在Android Studio 3.6 Canary 11 及更高版本中可用。 要在某个模块中启用视图绑定，请将viewBinding元素添加到其build.gradle文件中，如下例所示： android { ... viewBinding { enabled = true } } 如果您希望在生成绑定类时忽略某个布局文件，请将tools:viewBindingIgnore=\"true\"属性添加到相应布局文件的根视图中： ... 2.1 用法 为某个模块启用视图绑定功能后，系统会为该模块中包含的每个 XML 布局文件生成一个绑定类。每个绑定类均包含对根视图以及具有 ID 的所有视图的引用。系统会通过以下方式生成绑定类的名称：将 XML 文件的名称转换为驼峰式大小写，并在末尾添加“Binding”一词。 例如，假设某个布局文件的名称为result_profile.xml： 所生成的绑定类的名称就为ResultProfileBinding。此类具有两个字段：一个是名为name的TextView，另一个是名为button的Button。该布局中的ImageView没有 ID，因此绑定类中不存在对它的引用。 每个绑定类还包含一个getRoot()方法，用于为相应布局文件的根视图提供直接引用。在此示例中，ResultProfileBinding类中的getRoot()方法会返回LinearLayout根视图。 2.1.1 在 Activity 中使用视图绑定 请在 Activity 的onCreate()方法中执行以下步骤： 调用生成的绑定类中包含的静态inflate()方法。此操作会创建该绑定类的实例以供 Activity 使用。 通过调用getRoot()方法或使用Kotlin 属性语法获取对根视图的引用。 将根视图传递到setContentView()，使其成为屏幕上的活动视图。 private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // R.layout.activity_main // ViewBinding binding = ActivityMainBinding.inflate(layoutInflater) val rootView = binding.root setContentView(rootView) // TextView -> id=@+id/textView binding.textView // Button -> id=@+id/update binding.update } 2.1.2 在 Fragment 中使用视图绑定 请在 Fragment 的onCreateView()方法中执行以下步骤： 调用生成的绑定类中包含的静态inflate()方法。此操作会创建该绑定类的实例以供 Fragment 使用。 通过调用getRoot()方法或使用Kotlin 属性语法获取对根视图的引用。 从onCreateView()方法返回根视图，使其成为屏幕上的活动视图。 class BlankFragment : Fragment() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) } private var binding: FragmentBlankBinding? = null override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { // R.layout.fragment_blank binding = FragmentBlankBinding.inflate(inflater, container, false) val rootView = binding?.root return rootView } override fun onDestroy() { super.onDestroy() binding = null } } Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"数据绑定.html":{"url":"数据绑定.html","title":"数据绑定","keywords":"","body":"[TOC] 1. 说明 本篇博客参考Data Binding in Android (google.cn) 和 数据绑定库 数据绑定可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。其实有点类似于MVVM框架，数据和显示的部分动态绑定，当数据发生改变对应的视图也随之改变。如果您使用数据绑定的主要目的是取代findViewById()调用，请考虑改用视图绑定。其模式示意图： 和视图绑定类似，对于Android Studio的版本也有要求： Android Studio 3.4 or greater 2. 使用 2.1 环境准备 类似的，直接在配置文件中添加： android { ... dataBinding { enabled = true } } 将之前的layout布局文件修改为DataBinding layout。直接右击根布局的标签元素，然后选择Show Context Actions： 然后就可以看见提供了直接转换到data binding布局的选项： 比如我这里转换后的xml布局文件为： 在data标签中的内容，也就是定义的变量。比如可以定义如下的两个变量： 因为后续需要使用View，所以这里需要导入包。对应的，可以使用自定义的类，然后导入对应的包即可。 2.2 根据name长度显示Message案例 将定义的变量和布局文件中的控件关联，也就是使用变量。在Android Jetpack中定义的使用方式为@{ expression }的格式，也就是可以如下使用： 3) ? View.VISIBLE : View.GONE }\" ... /> 然后就是在代码中设置在xml中申明的两个变量的值。和viewbinding类似在databinding中也需要在onCreate方法替换： setContentView(R.layout.plain_activity) 这里替换为： binding = DataBindingUtil.setContentView( this, R.layout.activity_main ) 所获得的binding对象也就是和布局文件相关联的类，即：ActivityMainBinding。通过binding这个实例，就能够直接操作在xml中声明的变量： binding.name = \"testDemo\" binding.message = \"Hello data binding.\" 完整代码： class MainActivity2 : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 1. setContentView(R.layout.plain_activity) replace with below: // data binding binding = DataBindingUtil.setContentView( this, R.layout.activity_main ) // 2. set the variable values binding.name = \"testDemo\" binding.message = \"Hello data binding.\" } } 结果： 2.3 响应点击事件 通常我们可以直接在xml中直接设置点击函数，比如： android:onClick=\"onButtonClick\" 然后在Activity中定义方法onButtonClick。或者直接通过这个按钮的实例对象来注册监听，进行事件处理。这里也是类似，可以在xml中采用Lambda表达式的方式来注册函数。首先定义一个SimpleViewModel类，继承自ViewModel类，如下： /** * @author 梦否 on 2022/3/29 * @blog https://mengfou.blog.csdn.net/ */ class SimpleViewModel: ViewModel() { // 定义消息 var message = \"Hello data binding.\" get() { return if(clickNumber % 2 == 0) \"偶数\" else \"奇数\" } private set // 阻止外部修改，只支持内部修改 val name = \"testDemo\" var clickNumber = 0 private set // 定义点击函数 fun onTextViewClick(){ clickNumber++ Log.e(\"TAG\", \"onTextViewClick: ${clickNumber}\" ) } } 但是，很不幸，点击TextView之后，在TextView中显示的文本并没有观测到数据的变化。观察日志： 其实，这是因为我们设置的数据并不可观测。我们需要让数据可以observable才行。为了让字段可观测，可以使用observable类或者LiveData。关于可观察的数据对象在Google中有详细说明：使用可观察的数据对象。 2.4 可观察数据类型 可观察类有三种不同类型：对象、字段和集合。 2.4.1 可观测对象 实现Observable接口的类允许注册监听器，以便它们接收有关可观察对象的属性更改的通知。为便于开发，数据绑定库提供了用于实现监听器注册机制的BaseObservable类。实现BaseObservable的数据类负责在属性更改时发出通知。具体操作过程是向 getter 分配Bindable注释，然后在 setter 中调用notifyPropertyChanged()方法。 2.4.2 可观测字段 ObservableField() 以及基本的： 2.4.3 可观察集合 ObservableArrayMap、ObservableArrayList等。 2.5 设置数据可观察 因为这里所使用的为基本类型，比如message和name。由于这里我只需要message可观测，所以这里对其应用可观测字段即可。如下： /** * @author 梦否 on 2022/3/29 * @blog https://mengfou.blog.csdn.net/ */ class SimpleViewModel : ViewModel() { // 定义可观测的字段，使用ObservableField var message = ObservableField(\"Hello data binding.\") private set // 阻止外部修改，只支持内部修改 val name = \"testDemo\" var clickNumber = 0 private set // 定义点击函数 fun onTextViewClick() { clickNumber++ if (clickNumber.rem(2) == 0) message.set(\"is Even\") else message.set(\"is odd\") Log.e(\"TAG\", \"onTextViewClick: ${clickNumber}\") } } 对应的修改在xml中的标签中的变量声明： 对应的MainActivity文件： class MainActivity2 : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 1. setContentView(R.layout.plain_activity) replace with below: // data binding binding = DataBindingUtil.setContentView( this, R.layout.activity_main ) // set data binding.viewModel = SimpleViewModel() } } 然后就可以看见点击后奇数点击和偶数点击的切换显示文本效果。 2.6 数据双向绑定 在这个案例中需要达到的效果为：对应定义的可观测字段Field内容的改变可以通知到对应的控件，而控件的内容变化也可以通知到Field。所以这里可以使用控件EditText。 2.6.1 方式一：继承自BaseObservable 在布局文件中定义一个EditText和TextView，如下： 值得注意的是，在EditText中设置为： android:text=\"@={ myViewModel.userInput }\" 而在TextView中为： android:text=\"@{ myViewModel.userInput }\" 因为在EditText中我们需要完成双向绑定，即用户输入可以通知到LiveData，而在TextView中只要加载变化后的数据即可。 那么，在自定义ViewModel中为： /** * @author 梦否 on 2022/4/20 * @blog https://mengfou.blog.csdn.net/ */ class MyViewModel :BaseObservable(){ // 设置为LiveData，便于布局文件中TextView内容的自动更新 private val userInput = MutableLiveData(\"Tom\") // 这里一定不要忘记添加注解@Bindable，否则双向绑定不会生效 @Bindable @JvmName(\"getUserInput\") fun getUserInput(): String{ return userInput.value.toString() } // 用于更新TextView fun get(): LiveData { return this.userInput } @JvmName(\"setUserInput\") fun setUserInput(str: String){ if(!str.equals(userInput)) { this.userInput.value = str } Log.e(\"TAG\", \"setValue: ${str}\" ) // 通知数据发生了改变 notifyPropertyChanged(BR.myViewModel) // build后会自动生成一个BR类，对应在xml中声明的变量 } } 这里为了完成双向绑定，继承自BaseObservable，且在get方法上使用了@Bindable注解来表示绑定。至于get()方法仅是为了返回LiveData对象，然后在Activity中设置观察，更新TextView控件内容： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main2 ) // 这里直接使用new一个对象 // 因为这里的自定义ViewModel继承的是BaseObservable类，不是ViewModel类 val myViewModel = MyViewModel() binding.myViewModel = myViewModel // 设置观察，以更新TextView文本 myViewModel.get().observe(this) { binding.textView2.text = myViewModel.get().value } } } 效果： 2.6.2 方式二：继承自ObservableField 布局文件还是保持不变： 对于ViewModel进行删减： class MyViewModel { // 设置为可观察类型 val userInput = ObservableField(\"Tom\") } 最后在Activity中进行设置数据： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main2 ) // 这里直接使用new一个对象 // 因为这里的自定义ViewModel继承的是BaseObservable类，不是ViewModel类 val myViewModel = MyViewModel() binding.myViewModel = myViewModel // 在xml文件：@=操作符进行双向绑定 } } 达到的效果和上小节一样。 2.7 RecyclerView+dataBinding 可以使用databinding来设置每个item的内容。比如在主布局文件： 因为使用了RecyclerView，所以这里还是定义对应的适配器： /** * @author 梦否 on 2022/4/20 * @blog https://mengfou.blog.csdn.net/ */ class MyRecycleViewAdapter(var context: Context, var datas: List) : RecyclerView.Adapter() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder { val inflater = LayoutInflater.from(context) val binding = DataBindingUtil.inflate( inflater, R.layout.recyclerview_item, parent, false ) val myViewHolder = MyViewHolder(binding.root) myViewHolder.binding = binding return myViewHolder } override fun onBindViewHolder(holder: MyViewHolder, position: Int) { holder.binding?.user = datas[position] Log.e(\"TAG\", \"onBindViewHolder: ${position} + ${ datas[position].name }\") } override fun getItemCount(): Int { return datas.size } inner class MyViewHolder(var root: View) : RecyclerView.ViewHolder(root) { var binding: RecyclerviewItemBinding? = null } } 同样的在R.layout.recyclerview_item布局文件中设置databinding： 对于User类比较简单： class User(var age: Int, var name: String) { var image = \"https://i1.hdslb.com/bfs/face/7e72c58637ff26df68fb30939de078d2bbbfcdbe.jpg\" } 在主Activity中配置： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main3 ) val datas = listOf( User(12, \"Jack\"), User(10, \"Tom\"), User(23, \"Joe\") ) // 必须设置布局管理器，否则不会显示RecyclerView binding.recyclerView.layoutManager = LinearLayoutManager(this) binding.recyclerView.adapter = MyRecycleViewAdapter(this, datas) } } 运行即可看见效果。 3. 自定义BindingAdapter 参考视频地址：https://www.bilibili.com/video/BV1Ry4y1t7Tj?p=12 这个案例感觉比较典型，达到的效果为可以使用databinding的方式传入一个图片的链接地址，然后可以通过注解的方式来直接定义属性字段。然后可以完成加载。比如下面的案例： 布局文件： 注意到，在ImageView标签中直接设置了自定义的字段： app:imageSrc=\"@{ src }\" 而这个字段以前我们是需要使用tool:并定义对应的styleable样式。这里并不需要，仅需要使用注解来申明： class ImageViewCus { // 需要注意的是，这里需要使用静态方法 companion object{ @JvmStatic @BindingAdapter(\"app:imageSrc\") fun loadImage(imageView: ImageView, str: String){ Glide.with(imageView.context) .load(str) .placeholder(R.drawable.ic_launcher_background) .into(imageView) } } } 最后是在Activity中使用： class MyBindingAdapterActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_binding_adapter ) binding.src = \"https://img-blog.csdnimg.cn/5690c131d90e460fa4c96bf86b1ae634.png\" } } 传入databinding中声明的字符串即可，就可以达到预期的效果。整体的使用流程感觉和SpringBoot中的类似，但是这里比较好奇的是难道这里也会扫描所有包/类中的注解？应该是的，等储备知识够了再深入。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"【AndroidJetpack】Room.html":{"url":"【AndroidJetpack】Room.html","title":"【Android Jetpack】Room——基本使用","keywords":"","body":"[toc] 1. 前言 当然，我们所使用的就是之前使用过的SQLite数据库。可以简单回顾一下在java中是如何操作数据库的： 继承自SQLiteOpenHelper类，复写对应的方法，可以得到一个Helper实例； 通过SQLiteOpenHelper的实例的getWritableDatabase()来得到一个数据库实例； 然后就可以通过这个数据库实例进行CRUD操作； 简单回顾一下在Java中的流程： // 构建一个子类Helper public class MySQLiteOpenHelper extends SQLiteOpenHelper { private Context context; private String name; private String bookSql = \"create table Book (id integer primary key autoincrement, \" + \"name text, pages integer)\"; private String userSql = \"create table User (name text, age integer)\"; public MySQLiteOpenHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); this.context = context; this.name = name; } @Override public void onCreate(SQLiteDatabase db) { // 创建数据库表 db.execSQL(bookSql); db.execSQL(userSql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { db.execSQL(\"drop table if exists Book\"); db.execSQL(\"drop table if exists User\"); onCreate(db); // 重新执行一下onCreate方法 } } // 获取db对象 mySQLiteOpenHelper = new MySQLiteOpenHelper(getApplicationContext(), \"BookDatabase.db\", null, 3); SQLiteDatabase db= mySQLiteOpenHelper.getWritableDatabase(); // CRUD db.insert(\"Book\", null, values); 2. Kotlin中的数据库操作 虽然在Kotlin中也可以像上面的那种方式一样来进行数据库的操作，但是Google推出了一款数据库框架，即：Room。下面就使用这个框架进行完成操作。 2.1 依赖 首先需要添加依赖： // Room def room_version = \"2.2.6\" implementation \"androidx.room:room-runtime:$room_version\" // For Kotlin use kapt instead of annotationProcessor (注意这个注释) kapt \"androidx.room:room-compiler:$room_version\" implementation \"androidx.room:room-ktx:$room_version\" testImplementation \"androidx.room:room-testing:$room_version\" 当然，这里在kotlin中使用kapt，我们需要导入这个插件： plugins { id 'com.android.application' id 'kotlin-android' id 'kotlin-kapt' } 注释：如果项目是使用Kotlin语言来开发的，在添加room-compiler的时候使用kapt关键字，java语言开发的就使用annotationProcessor关键字。 2.2 基础概念 要想使用Room，必须要了解最基础的三个概念： Entity：实体类，对应的是数据库的一张表结构。需要使用注解 @Entity 标记。默认实体类的类名为表名，字段名为数据库中的字段。 Dao：包含访问一系列访问数据库的方法。需要使用注解 @Dao 标记。 Database：数据库持有者，作为与应用持久化相关数据的底层连接的主要接入点。需要使用注解 @Database 标记。 使用@Database注解需满足以下条件： 定义的类必须是一个继承于RoomDatabase的抽象类。 在注解中需要定义与数据库相关联的实体类列表。 包含一个没有参数的抽象方法并且返回一个带有注解的 @Dao。 注释：以上基础概念摘自：Jetpack架构组件 — Room入坑详解 2.2 1 @Entity 从前面我们知道，@Entity作用在类上，该类对应数据库中的一个数据表。属性对应数据库中的字段，那么类似的我们可以指定主键和注释。同样也是使用注解： @PrimaryKey注解用来标注表的主键，可以使用autoGenerate = true来指定了主键自增长； @ColumnInfo注解用来标注表对应的列的信息比如表名、默认值等等。 @Ignore 注解顾名思义就是忽略这个字段，使用了这个注解的字段将不会在数据库中生成对应的列信息。 2.2.2 @Dao Dao类是一个接口，其中定义了一系列的操作数据库的方法。Room也为我们的提供了相关的注解，有@Insert、@Delete、@Update 和 @Query。 比如： @Query(\"select * from user where userId = :id\") fun getUserById(id: Long): User 2.2.3 @Database 首先需要定义一个类，继承自RoomDatabase，并添加注解 @Database 来标识。 2.3 实战 这里我们需要一个数据库来存储用户记事本的数据，大致包括如下内容： | 字段 | 说明 | | --- | --- | | title | 标题 | | content | 数据内容 | | firstSubmit | 首次提交时间 | | lastModifiy | 最后一次修改时间 | | type | 类型，普通记事或者待办 | | label | 标签，支持多个，使用#号分割 | | category | 分类，工作/学习/生活/... | | groupId | 组号，默认为1，表示单个记录；如果为多个，表示前端显示为重叠 | 那么首先我们需要使用@Entity注解来生成逻辑的表（MFNote）： @Entity class MFNote { @PrimaryKey(autoGenerate = true) var noteId: Int = 0 @ColumnInfo(defaultValue = \"无标题\") lateinit var title: String @ColumnInfo(defaultValue = \"\") lateinit var content: String @ColumnInfo(name = \"first_submit\") var submit: String? = null @ColumnInfo(name = \"last_modify\") var modify: String? = null var type: Int = 0 @ColumnInfo(defaultValue = \"默认\") lateinit var label: String @ColumnInfo(defaultValue = \"默认\") lateinit var category: String @ColumnInfo(name = \"group_id\") var groupId: Int = 1 } 然后构建一个访问MFNote表的DAO接口（MFDao）： @Dao interface MFDao { @Insert(onConflict = OnConflictStrategy.REPLACE) fun insert(mfNote: MFNote?) @Delete fun delete(mfNote: MFNote): Int @Query(\"select * from MFNote\") fun getAllNotes(): List @Query(\"select * from MFNote where type = :type\") fun getNotesByType(type: Int): MFNote @Update fun updateNoteByNote(mfNote: MFNote) } 参数onConflict，表示的是当插入的数据已经存在时候的处理逻辑，有三种操作逻辑：REPLACE、ABORT和IGNORE。如果不指定则默认为ABORT终止插入数据。这里我们将其指定为REPLACE替换原有数据。 最后需要构建Room使用的入口RoomDatabase。 @Database(entities = [MFNote::class], version = 1) abstract class MFNoteDataBase : RoomDatabase() { abstract fun mfDao(): MFDao companion object { @Volatile private var mInstance: MFNoteDataBase? = null private const val DATABASE_NAME = \"MFNote.db\" @JvmStatic fun getInstance(context: Context): MFNoteDataBase? { if (mInstance == null) { synchronized(MFNoteDataBase::class.java) { if (mInstance == null) { mInstance = createInstance(context) } } } return mInstance } private fun createInstance(context: Context): MFNoteDataBase { mInstance = Room.databaseBuilder( context.applicationContext, MFNoteDataBase::class.java, DATABASE_NAME ).build() return mInstance as MFNoteDataBase } } } 在这里我们只需要对一个数据库表进行操作，所以就定义了一个抽象接口。如果需要定义多个，比如下面的写法： @Database(entities = [User::class, Course::class, Teacher::class, UserJoinCourse::class, IDCard::class], version = 1) abstract class AppDataBase : RoomDatabase() { abstract fun userDao(): UserDao abstract fun teacherDao(): TeacherDao abstract fun courseDao(): CourseDao abstract fun userJoinCourseDao(): UserJoinCourseDao abstract fun idCardDao(): IDCardDao } @Database 表示继承自RoomDatabase的抽象类，entities指定表的实现类列表，version指定了DB版本 必须提供获取DAO接口的抽象方法，比如上面定义的movieDao()，Room将通过这个方法实例化DAO接口 接下来就是调用了： class TestActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_test) // 调用Room数据库 val mfDao = MFNoteDataBase.getInstance(this)?.mfDao() mfDao?.insert(MFNote()) mfDao?.getAllNotes()?.forEach { Log.e(\"TAG\", \"onCreate: ${it.title}, ${it.category}\" ) } } } 结果： 最终我在Dao层添加了如下方法： @Dao interface MFDao { @Insert(onConflict = OnConflictStrategy.REPLACE) fun insert(mfNote: MFNote?) @Delete fun delete(mfNote: MFNote): Int @Query(\"select * from MFNote\") fun getAllNotes(): List @Query(\"select * from MFNote where noteId = :id\") fun getNoteByNoteId(id: Int): MFNote @Query(\"select * from MFNote where type = :type\") fun getNotesByType(type: Int): List @Query(\"select * from MFNote where label like '%' || :label || '%'\") fun getNotesByLabel(label: String): List @Query(\"select * from MFNote where category like '%' || :category || '%'\") fun getNotesByCategory(category: String): List @Query(\"select * from MFNote where group_id = :groupId\") fun getNotesByGroupId(groupId: Int): List @Query(\"select * from MFNote where first_submit >= :beginTime and first_submit @Query(\"select * from MFNote where first_submit >= :beginTime\") fun getNotesByStartSubmitTime(beginTime: String): List @Query(\"select * from MFNote where first_submit @Query(\"select * from MFNote where last_modify >= :beginTime and last_modify @Query(\"select * from MFNote where last_modify >= :beginTime\") fun getNotesByStartModifyTime(beginTime: String): List @Query(\"select * from MFNote where last_modify @Query(\"select * from MFNote where (title like '%' || :words || '%') or (content like '%' || :words || '%') or (first_submit like '%' || :words || '%') or (last_modify like '%' || :words || '%') or (label like '%' || :words || '%') or (category like '%' || :words || '%')\") fun getNodesByKeyWords(words: String): List @Update fun updateNoteByNote(mfNote: MFNote) } 测试代码： class TestActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_test) // 调用Room数据库 val mfDao = MFNoteDataBase.getInstance(this)?.mfDao() val mfNote = MFNote() mfNote.title = \"测试\" mfNote.content = \"第一条测试\" mfDao?.insert(mfNote) mfDao?.getAllNotes()?.forEach { Log.e(\"TAG\", \"onCreate: ${it.title}, ${it.category}\" ) } val notesByType = mfDao?.getNotesByType(0) notesByType?.forEach { Log.e(\"TAG\", \"onCreate: ${it.title}, ${it.category}\" ) } val entity = mfDao?.getNoteByNoteId(2) Log.e(\"TAG\", \"onCreate: ${entity?.title}, ${entity?.firstSubmit}\" ) entity?.title = \"厉害\" mfDao?.updateNoteByNote(entity!!) } } 以上代码均测试通过。 3. 数据库版本升级（Migration） 3.1 正常升级 数据库版本升级，也就是在原来的表中加入一些字段内容。在Room中提供了比较便捷的数据库升级方式。直接使用Migration来可以完成。甚至可以完成跳版本的升级，比如当前用户版本为1，而最新的版本为3，那么Room可以依次执行1-2-3的过程。比如此时我有一个表User，如下： 当然，对应的Room的使用这里不再介绍。此时的需求为在表中新增一个字段：nickName。那么可以在创建数据库的时候进行添加Migration： private fun createInstance(context: Context): UserDataBase { mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).addMigrations(Migration_1_2) // 数据库版本升级 .build() return mInstance as UserDataBase } // Migration(int startVersion, int endVersion) private val Migration_1_2 = object : Migration(1, 2) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\"alter TABLE User add column nickName TEXT default '123' not null\") } } 对应的，需要在@Entity注释的类中添加对应的字段： @ColumnInfo(name = \"nickName\", typeAffinity = ColumnInfo.TEXT) var nickname = \"\" 然后将之前的@Database注释的版本改为目标版本2： @Database(entities = arrayOf(User::class), version = 2, exportSchema = false) abstract class UserDataBase : RoomDatabase() 最后，就可以查看下数据库： 数据更新后的表： 当然，如果需要从版本1升级到版本3，就可以对应的定义: private val Migration_1_2 = object : Migration(1, 2) private val Migration_2_3 = object : Migration(2, 3) 以及在表中的字段定义好，然后在创建数据库的时候进行使用： mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).addMigrations(Migration_1_2, Migration_2_3) // 数据库版本升级 .build() 3.2 异常升级 参考文档：手动迁移 值得注意的是，有些时候可能敲错了，在@Database注解的参数中指定了一个不存在的版本，会导致程序的异常退出。比如此时我这里没有写2到3版本的升级Migration和添加对应的字段，当指定3后程序异常退出，报错为： Caused by: java.lang.IllegalStateException: A migration from 2 to 3 was required but not found. Please provide the necessary Migration path via RoomDatabase.Builder.addMigration(Migration ...) or allow for destructive migrations via one of the RoomDatabase.Builder.fallbackToDestructiveMigration* methods. 根据提示说明，知道要么添加一个新的Migration来指定添加的表字段，要么指定fallbackToDestructiveMigration方法。这里就添加一个fallbackToDestructiveMigration方法，即： mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).addMigrations(Migration_1_2) // 数据库版本升级 .fallbackToDestructiveMigration() .build() 最后，程序可以正常运行，但是用户数据库文件中的数据均会清空（破坏性地重新创建应用的数据库表，Room 在尝试执行没有定义迁移路径的迁移时会从数据库表中永久删除所有数据）。 3.3 Scheme文件 再次回顾一下@Database的注解： @Database(entities = arrayOf(User::class), version = 3, exportSchema = false) abstract class UserDataBase : RoomDatabase() 使用的时候，exportSchema指定为false，也就是不需要Schema文件。这里可以设置为true，然后在配置文件中指定一下生成的路径： android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments = [\"room.schemaLocation\": \"$projectDir/schemas\".toString()] } } } } 在项目路径下就可以看见生成的json文件： 导出的 JSON 文件代表数据库的架构历史记录。您应将这些文件存储在版本控制系统中，因为此系统允许Room 出于测试目的创建较旧版本的数据库。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"Livedata.html":{"url":"Livedata.html","title":"【Android Jetpack】Livedata","keywords":"","body":"[toc] 1. 前言 官网地址：https://developer.android.google.cn/topic/libraries/architecture/livedata 其实在使用ViewModel和LifeCycle的时候，我们已经看见了LiveData这个组件。在这篇博客中将继续来了解这个组件。其特点： LiveData是一种可观察的数据存储器类； 与常规的可观察类不同，LiveData具有生命周期感知能力。其感知能力遵循其他组件（如 Activity、Fragment 或 Service）的生命周期； 感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者；活跃的观察者对象声明周期处于STARTED或 RESUMED 状态； LiveData只会将更新通知给活跃的观察者，非活跃观察者不会收到更改通知； 当观察者组件的Lifecycle对象的状态变为 DESTROYED 时，便可移除此观察者，不必担心泄露（当 Activity和Fragment的生命周期被销毁时，系统会立即退订它们）。 不妨再次看下这个图： 1.1 关于观察者模式 我们知道观察者模式，在Java中提供了Observable和Observer来定义被观察者和观察者对象。然后对于可观察对象可以设置观察者，来监听其变化。而在Android的Lifecycle包中提供了对应的LifecycleOwner和LifecycleObserver，而在Activity、Fragment 或 Service等组件中已经实现了LifecycleOwner接口，我们在使用的时候，只需要实现LifecycleObserver来标识类是一个观察者，以注册观察。在之前的博客：【Android Jetpack】LifeCycle一文中也曾提到过通过： lifecycle.addObserver(myLocationObserver) 来为lifecycle来设置一个观察者对象。类似的，前面提到了：LiveData也是一种可观察的数据存储器类。故而也可以设置观察对象，比如： // viewModel.get() 获取的为LiveData对象 viewModel.get().observe(this, object : androidx.lifecycle.Observer{ override fun onChanged(value: Int?) { livedataText.text = viewModel.getValue().toString() } }) 2. LiveData 的优势 确保界面符合数据状态；LiveData 遵循观察者模式。当底层数据发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中更新界面。 不会发生内存泄漏；观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。 不会因 Activity 停止而导致崩溃；如果观察者的生命周期处于非活跃状态，则它不会接收任何 LiveData 事件。 不再需要手动处理生命周期； 共享资源；可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。 更加通俗来说，LiveData是一个持有Activity、Fragment生命周期的数据容器。当数据源发生改变的时候，可以通知观察者。 2.1 案例一：计时器效果 在Activity中定义一个文本，在该控件上每秒自动加一操作。且屏蔽设备配置发生改变后不影响其状态。比如布局文件为ConstraintLayout下放置一个居中的TextView。 2.1.1 实现方式一：ViewModel+LiveData 因为需要屏蔽设备配置发生改变的影响，故而这里考虑直接使用ViewModel； 考虑代码解耦，这里使用LiveData来设置观察者，也即是我们需要在ViewModel中设置数据类型为LiveData； 自定义的ViewModel如下： class MyNumberViewModel : ViewModel() { private var number: MutableLiveData = MutableLiveData(0) fun set(value: Int) { number.value = value } // 工作线程需要使用Post fun post(value: Int) { number.postValue(value) } fun get(): LiveData { return number } fun getValue(): Int{ return number.value?:0 } } 因为我们需要使用LiveData对象来注册观察者对象，故而这里get()方法返回的是LiveData对象。且因为需要开启定时任务，故而可以在工作线程完成，所以提供了post方法，然后在Activity中进行设置： class LiveDataActivity : AppCompatActivity() { private lateinit var viewModel: MyNumberViewModel private val livedataText: TextView by lazy { findViewById(R.id.livedata_text)} override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_live_data) // 获取到ViewModel viewModel = ViewModelProvider( this, ViewModelProvider.NewInstanceFactory() ).get(MyNumberViewModel::class.java) // 为TextView设置数据 livedataText.text = viewModel.get().toString() // 开始定时任务 startTimer() // 注册一个观察者，监听到ViewModel中数据的变化，如果变化执行onChanged()方法 // viewModel.get() 获取的为LiveData对象 viewModel.get().observe(this, object : androidx.lifecycle.Observer{ override fun onChanged(value: Int?) { livedataText.text = viewModel.getValue().toString() } }) } // 定时任务 private fun startTimer(){ Timer().schedule( object : TimerTask() { override fun run() { viewModel.post(viewModel.getValue() + 1) } }, 1000, 1000, ) } } 运行即可看见预想的效果。看完上述案例代码之后是否会有疑惑？肯定是有的，因为这里是LiveData的案例，却引入了ViewModel，且将LiveData放入了自定义的ViewModel类中，为什么需要这么做？LiveData对象本身就可以被观察，为什么还需要放置到ViewModel中？ 答：其实在刚开始的要求部分我已经做了引导，需要做到屏蔽设备配置发生改变后不影响其状态，而很方便的ViewModel就可以轻松做到这一点。如果LiveData实例与特定的 Activity 或 Fragment 实例并没有分离开，那么在 Activity 或 Fragment 经历onDestory的时候，LiveData中的数据也就没了。 且上述程序存在一个致命Bug，由于每次屏幕旋转都会执行onCreate，故而会开启多个定时任务，故而这里是不符合题意的。当然，可以加上标志处理，这里不再解决。 2.1.2 实现方式二：configChange 当然，上述使用ViewModel只是一种方式，也可以配置清单文件，设置onConfigChange属性，这里来尝试写一下： 然后将LiveData直接定义在Activity中： class LiveDataActivity : AppCompatActivity() { private val livedataText: TextView by lazy { findViewById(R.id.livedata_text) } private val liveData: MutableLiveData by lazy { MutableLiveData(0) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_live_data) // 为TextView设置数据 livedataText.text = liveData.value.toString() // 开始定时任务 startTimer() // 注册一个观察者，监听到ViewModel中数据的变化，如果变化执行onChanged()方法 // viewModel.get() 获取的为LiveData对象 liveData.observe(this) { livedataText.text = liveData.value.toString() } } override fun onConfigurationChanged(newConfig: Configuration) { super.onConfigurationChanged(newConfig) Log.e(\"TAG\", \"onConfigurationChanged: \") } // 定时任务 private fun startTimer() { Timer().schedule( object : TimerTask() { override fun run() { liveData.postValue((liveData.value ?: 0) + 1) Log.e(\"TAG\", \"run: ${liveData.value ?: 0}\", ) } }, 1000, 1000, ) } } 2.2 案例二： Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:27 "},"【AndroidJetpack】Room+ViewModel+LiveData.html":{"url":"【AndroidJetpack】Room+ViewModel+LiveData.html","title":"【Android Jetpack】Room+ViewModel+LiveData","keywords":"","body":"[toc] 1. 前言 实现内容： 使用Room框架来完成数据库的CRUD操作； 对于查询到的数据库数据，使用LiveData进行封装，使得每次数据库中数据更新后都可以自动渲染到RecyclerView控件； 2. 实现 最后效果： 文件结构： 2.1 定义Room相关的结构 User表： @Entity(tableName = \"User\") class User { @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"userId\", typeAffinity = ColumnInfo.INTEGER) var id = 0 @ColumnInfo(name = \"userName\", typeAffinity = ColumnInfo.TEXT) var name = \"\" @ColumnInfo(name = \"userAge\", typeAffinity = ColumnInfo.INTEGER) var age = 10 // 可以让创建的时候忽略这个属性 @Ignore var date = \"2022年4月20日20:59:20\" } 使用@Entity注解标识表，使用tableName可以定制表名。@ColumnInfo来指定字段，typeAffinity用于指定该字段在数据库中的类型。最后的@Ignore标签可以用来忽略不需要加入到表中的数据。 同样可以在应用目录下找到这个数据库文件。不妨使用SQLiteStudio打开这个数据库文件： 可以看见确实@Ignore标签修饰的字段没有生成。 其实和SQLite差不多，只是做了一层封装。使得使用起来更简洁。 然后就是定义对应的接口操作层，有点类似于SpringBoot中常写的Service层： @Dao // 这个注解仅用作标识 interface UserDao { @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertUser(user: User): Unit @Delete fun deleteUser(user: User): Unit @Query(\"select * from User\") fun getAllUser(): LiveData> @Query(\"select * from User where userId = :userId\") fun getUserById(userId: Int): User @Update(onConflict = OnConflictStrategy.REPLACE) fun updateUser(user: User) } 上面值得注意的是其中一个方法，即： @Query(\"select * from User\") fun getAllUser(): LiveData> 在返回的数据List可以直接使用LiveData来进行包起来。最后是获取数据库实例的类，这个类定义为单例，所有的数据库中表相关的Dao层不需要实现，声明为抽象方法，具体的实现由Room自动实现，所以这个类也需要声明为abstract： @Database(entities = arrayOf(User::class), version = 1, exportSchema = false) abstract class UserDataBase : RoomDatabase() { // 定义的抽象方法，由Room自动实现，我们不需要实现 abstract fun userDao(): UserDao companion object { // 单例模式 private var mInstance: UserDataBase? = null private const val DATABASE_NAME = \"User.db\" @JvmStatic fun getInstance(context: Context): UserDataBase? { if (mInstance == null) { synchronized(UserDataBase::class.java) { if (mInstance == null) { mInstance = createInstance(context) } } } return mInstance } private fun createInstance(context: Context): UserDataBase { mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).build() return mInstance as UserDataBase } } } 1.2 定义Repository 然后定义一层Repository，类似于SpringBoot中的Controller层。添加这一层主要是因为在Room要求数据操作不能在UI线程中，需要在子线程中进行操作。且在这个类中完成获取数据库的实例对象，然后再次封装CRUD方法，可以在自定义ViewModel的类中更加简洁。 /** * @author 梦否 on 2022/4/20 * @blog https://mengfou.blog.csdn.net/ */ class UserRepository(var context: Context) { private var userDao: UserDao? = null init { // 获取到数据库操作的Dao层接口 userDao = UserDataBase.getInstance(context)?.userDao() } // Android-Room要求数据操作不能在UI线程中，需要在子线程中进行操作 fun insertUser(user: User) { GlobalScope.launch { userDao?.insertUser(user) } } fun deleteUserById(id: Int) { val user = User().apply { this.id = id } GlobalScope.launch { userDao?.deleteUser(user) } } fun updateUser(user:User){ GlobalScope.launch { userDao?.updateUser(user) } } fun getAllUsers(): LiveData>? { return userDao?.getAllUser() } } 1.3 定义ViewModel 最后在ViewModel中共只需要完成获取所有数据即可。因为返回的是LiveData所以我们可以设置监听： class UserViewModel() : ViewModel() { var repository: UserRepository? = null var context: Context? = null fun getUsers(): LiveData>? { val allUsers = repository?.getAllUsers() return allUsers } } 1.4 定义RecyclerView 在布局文件中，因为需要使用RecyclerView来渲染数据，所以这里首先定义一个适配器类，且在这个控件需要完成数据库中数据发生改变后就自动渲染。所以这里使用dataBinding来定义布局文件： 然后定义对应的适配器： class MyRecyclerViewAdapter(val context: Context, var datas: List) : RecyclerView.Adapter() { fun setData(datas: List) { this.datas = datas } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder { val binding = DataBindingUtil.inflate( LayoutInflater.from(context), R.layout.room_recyclerview_item, parent, false ) val myViewHolder = MyViewHolder(binding.root).apply { this.binding = binding } return myViewHolder } override fun onBindViewHolder(holder: MyViewHolder, position: Int) { datas.apply { holder.binding?.user = datas.get(position) } } override fun getItemCount(): Int { return datas.size } inner class MyViewHolder(view: View) : RecyclerView.ViewHolder(view) { var binding: RoomRecyclerviewItemBinding? = null } } 1.5 定义Activity 最后就是在Activity中进行使用了： class MainActivity : AppCompatActivity() { private val userRepository: UserRepository by lazy { val userRepository = UserRepository(this) userRepository } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main2 ) val myViewModel = ViewModelProvider(this, ViewModelProvider.NewInstanceFactory()) .get(UserViewModel::class.java) myViewModel.context = this myViewModel.repository = userRepository val myRecyclerViewAdapter = MyRecyclerViewAdapter(this, userRepository.getAllUsers()?.value ?: ArrayList()) binding.recycleview.layoutManager = LinearLayoutManager(this) binding.recycleview.adapter = myRecyclerViewAdapter myViewModel.getUsers()?.observe(this) { myRecyclerViewAdapter.datas = it myRecyclerViewAdapter.notifyDataSetChanged() currentDatas = it } } private var count = 1 private var currentDatas: List? = null fun insert(view: View) { userRepository.insertUser(User().apply { name = \"张${ count++ }\" age = 20 }) } fun delete(view: View) { // 随机删除一个 currentDatas?.let { if(currentDatas!!.isNotEmpty()) { val index = (Math.random() * currentDatas!!.size).toInt() currentDatas?.get(index)?.id?.let { userRepository.deleteUserById(it) } } } } fun update(view: View) { currentDatas?.let { if(currentDatas!!.isNotEmpty()) { // 随机修改一个用户信息 val index = (Math.random() * currentDatas!!.size).toInt() currentDatas?.get(index)?.apply { name = \"update: ${ name }\" userRepository.updateUser(this) } } } } } 至于主布局文件，比较简单这里不再给出。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"【AndroidJetpack】Room——其余.html":{"url":"【AndroidJetpack】Room——其余.html","title":"【Android Jetpack】Room——其余","keywords":"","body":"[toc] 1. 前言 在前面两篇博客中介绍了Room的一些用法，简单了解了Room的使用。在这篇博客中，将继续对Room进行介绍。 2. Room总结 参考文档：Room Room是在SQLite上的一个层封装； 简化了传统使用SQLiteOpenHelper方式的复杂性，注解操作更加便捷； 数据库迁移更加方便，且能够记录每个版本的数据库表构成（json文件）； 其内三个最基础的组件为@Entity、@Dao、@Database，分别对应表、操作接口和数据库对象（抽象类）。这里不再重复介绍，可以查看博客：【Android Jetpack】Room 对于数据库实例化对象，需要遵循单例模式，在kotlin中需要使用@JvmStatic来进行标识，且对于每个表（即@Entity标识的类）的Dao接口需要申明，不需要实现。具体的实现由Room框架完成，也就是数据库实例化对象的类文件也为抽象类。对应的核心创建方法为： val db = Room.databaseBuilder( applicationContext, AppDatabase::class.java, \"database-name\" ).build() 2.1 复合主键 即使用多个列的组合对实体实例进行唯一标识，比如下面的案例： @Entity(primaryKeys = [\"firstName\", \"lastName\"]) data class User( val firstName: String?, val lastName: String? ) 2.2 忽略字段 在【Android Jetpack】Room一文中也提到过，可以使用@Ignore来忽略一些字段。 2.3 索引 我们知道在数据库表中，可以将数据库中的某些列编入索引，以加快查询速度。故而在创建表的时候，可以指定索引。比如下面的案例： @Entity(indices = [Index(value = [\"last_name\", \"address\"])]) data class User( val address: String?, @ColumnInfo(name = \"last_name\") val lastName: String?, @Ignore val picture: Bitmap? ) 2.4 SQL传递参数 2.4.1 简单参数 其实在前面的文章中我们都使用过，这里再次回顾一下，比如下面的案例： @Query(\"SELECT * FROM user WHERE age > :minAge\") fun loadAllUsersOlderThan(minAge: Int): Array 在注解@Query的参数中，这里传递参数使用:，比如:minAge。 2.4.2 集合参数 当然，有些时候需要使用集合类型的参数，比如下面的案例： @Query(\"SELECT * FROM user WHERE region IN (:regions)\") fun loadUsersFromRegions(regions: List): List 2.5 多表查询 2.5.1 普通条件查询 其实也就是SQL语句中的多表查询，比如： @Query( \"SELECT * FROM book \" + \"INNER JOIN loan ON loan.book_id = book.id \" + \"INNER JOIN user ON user.id = loan.user_id \" + \"WHERE user.name LIKE :userName\" ) fun findBooksBorrowedByNameSync(userName: String): List 2.5.2 联合查询 比如下面的案例，在SQL语句中返回的是user表和book的笛卡尔积表结果： @Query( \"SELECT * FROM user\" + \"JOIN book ON user.id = book.user_id\" ) fun loadUserAndBookNames(): Map> 返回值类型也值得注意，为Map>。当然还可以使用条件过滤，比如： @Query( \"SELECT * FROM user\" + \"JOIN book ON user.id = book.user_id\" + \"GROUP BY user.name WHERE COUNT(book.id) >= 3\" ) fun loadUserAndBookNames(): Map> Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"【AndroidJetpack】Room——对象之间的关系.html":{"url":"【AndroidJetpack】Room——对象之间的关系.html","title":"【AndroidJetpack】Room——对象之间的关系","keywords":"","body":"[toc] 1. 前言 在这篇博客中，介绍一下定义数据库表的时候的多种关系。参考文档地址：定义对象之间的关系 2. 多表关系 2.1 基本嵌套 在OOP的思想中，万物均对象。故而在创建用户类的时候，下面的写法并不陌生： data class Address( val street: String?, val state: String?, val city: String?, @ColumnInfo(name = \"post_code\") val postCode: Int ) @Entity data class User( @PrimaryKey val id: Int, val firstName: String?, @Embedded val address: Address? ) 注意在嵌套的时候，所使用的注解为@Embedded。执行完毕后，可以得到包含id、firstName、street、state、city和post_code的User表结构。 2.2 定义嵌套一对一关系 比如定义了两个表，为User和Library类。如下： @Entity data class User( @PrimaryKey val userId: Long, val name: String, val age: Int ) @Entity data class Library( @PrimaryKey val libraryId: Long, val userOwnerId: Long ) 注意到，在Library类中使用了userOwnerId来表示用户，对应User表中的userId字段，这里可以认为为外键关系，为了表示这种关系，可以再定义一个类，用@Relation注解来标识这种一对一关系。如下： data class UserAndLibrary( @Embedded val user: User, @Relation( parentColumn = \"userId\", entityColumn = \"userOwnerId\" ) val library: Library ) 将@Relation注释添加到子实体的实例，同时将parentColumn设置为父实体主键列的名称，并将entityColumn设置为引用父实体主键的子实体列的名称。最后，向 DAO 类添加一个方法，用于返回将父实体与子实体配对的数据类的所有实例。该方法需要 Room运行两次查询，因此应向该方法添加@Transaction注释，以确保整个操作以原子方式执行。 @Transaction @Query(\"SELECT * FROM User\") fun getUsersAndLibraries(): List 3. 案例 3.1 一对一关系 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"【AndroidJetpack】Navigation——基础入门.html":{"url":"【AndroidJetpack】Navigation——基础入门.html","title":"【AndroidJetpack】Navigation——基础入门","keywords":"","body":"[toc] 1. 什么是Navigation 在Jetpack里有一种管理Fragment的新架构模式，即：单个Activity嵌套多个Fragment的UI架构模式。分为三个关键部分： 导航图：包含所有导航相关信息的 XML 资源，便于我们理清页面间的关系。 NavHostFragment：显示导航图中目标的空白容器，可以认为是Fragment的容器。 NavController：用于控制页面的切换工作。 2. 为什么引入Navigation 在之前的开发中，通常使用FragmentManager和FragmentTransaction来管理Fragment之间的切换。对应的一般需要完成： App bar的管理、Fragment间的切换动画，以及Fragment间的参数传递。纯代码的方式使用起来不是特别友好，并且Fragment和App bar在管理和使用的过程中显得很混乱。 Android Jetpack应用指南-叶坤-微信读书 (qq.com) 而Jetpack提供了一个名为Navigation的组件可以解决上述问题。可以： 方便添加页面切换动画。 通过NavigationUI类，对菜单、底部导航、抽屉菜单导航进行统一的管理。 页面间类型安全的参数传递。 支持深层链接DeepLink。 包括导航界面模式（例如抽屉式导航栏和底部导航），用户只需完成极少的额外工作。 ViewModel支持 - 您可以将ViewModel的范围限定为导航图，以在图表的目标之间共享与界面相关的数据。 注意：如果要使用导航，则必须使用Android Studio 3.3 或更高版本。 3. 简单使用 3.1 环境 引入依赖： def nav_version = \"2.4.2\" implementation(\"androidx.navigation:navigation-fragment-ktx:$nav_version\") implementation(\"androidx.navigation:navigation-ui-ktx:$nav_version\") 在res目录下创建navigation目录： 然后新建一个nav_graph.xml文件： 3.2 布局文件 使用android:name告诉系统，这是一个特殊的Fragment。 app:defaultNavHost属性设置为true，则该Fragment会自动处理系统返回键（设置为true后NavHostFragment会拦截系统返回按钮）。 app:navGraph用于指定导航图。 为了测试，这里新建两个fragment页面。然后在nav_graph.xml可视化界面配置fragment页面之间的链接关系。如果navigation的可视化界面一直加载，可以尝试清理一下AS的缓存，即：File -> Invalidate Caches/Restart。然后点击加号进行添加刚添加的Fragemnt： 然后通过拖拽的方式添加action： 在xml文件中，可以看见： 对应的新增了一个action，并且指定了目的地为secondFragment3。 3.3 处理逻辑 然后在FirstFragment添加点击事件，为了方便这里使用ViewBinding来完成控件的查找。并设置对应的跳转，比如： class FirstFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { val binding = FragmentFirstBinding.inflate(inflater, container, false) binding.textView.setOnClickListener { // 使用NavController Navigation.findNavController(it) .navigate(R.id.action_firstFragment_to_secondFragment3) } return binding.root } } 来完成跳转。然后可以设置在ActionBar自动添加返回箭头。 3.4 ActionBar返回箭头 只需要在MainActivity配置NavigationUI.setupActionBarWithNavController即可： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main4) val navController = Navigation.findNavController(this, R.id.nav_host_fragment_container) // 添加后才会在Action有对应的向上返回箭头图标 NavigationUI.setupActionBarWithNavController(this, navController) } } 结果： 3.5 返回键设置事件 注意到在3.4中只是显示了这个返回箭头，但是点击后没有事件响应。这里需要做一个处理，通过NavController来实现，需要在Activity中复写onSupportNavigateUp方法，比如下面的实现： class MainActivity : AppCompatActivity() { private lateinit var navController: NavController override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main4) navController = Navigation.findNavController(this, R.id.nav_host_fragment_container) // 添加后才会在Action有对应的向上返回箭头图标 NavigationUI.setupActionBarWithNavController(this, navController) } // 响应返回箭头 override fun onSupportNavigateUp(): Boolean { return navController.navigateUp() } } 添加后，返回按键就可以响应事件。 4. 导航到目的地 在前面我们已经使用了NavController来完成导航到目的地的操作。事实上Kotlin中可以使用六种方式来获取NavController： 导航方式一: Navigation.findNavController(View) binding.textView.setOnClickListener { //导航方式一: Navigation.findNavController(View) Navigation.findNavController(it) .navigate(R.id.action_firstFragment_to_secondFragment3) } 导航方式二: Fragment.findNavController() binding.textView.setOnClickListener { // 方式二: Fragment.findNavController() this@FirstFragment.findNavController() .navigate(R.id.action_firstFragment_to_secondFragment3) } 导航方式三: View.findNavController() binding.textView.setOnClickListener { // 方式三: View.findNavController() it.findNavController() .navigate(R.id.action_firstFragment_to_secondFragment3) } 导航方式四: Activity.findNavController(viewId: Int) binding.textView.setOnClickListener { // 方式四: Activity.findNavController(viewId: Int) // nav_host_fragment_container 为NavHostFragment容器 activity?.findNavController(R.id.nav_host_fragment_container) ?.navigate(R.id.action_firstFragment_to_secondFragment3) } 导航方式五：NavHostFragment.findNavController(Fragment) binding.textView.setOnClickListener { // 方式五：NavHostFragment.findNavController(Fragment) // NavHostFragment中注册了navigation controller作为根，故而可以找到 NavHostFragment.findNavController(this) .navigate(R.id.action_firstFragment_to_secondFragment3) } 导航方式六：Navigation.findNavController(Activity, @IdRes int viewId) binding.textView.setOnClickListener { // 方式六：Navigation.findNavController(Activity, @IdRes int viewId) activity?.let { it1 -> Navigation.findNavController(it1, R.id.nav_host_fragment_container) .navigate(R.id.action_firstFragment_to_secondFragment3) } } 5. 参数传递Sage Args 这里回顾一下之前非Jetpack开发中是如何来实现多个Fragment之间的参数传递的： 5.1 静态添加的fragment 如果Activity中fragment比较简单，且直接使用xml的android:name来指定自定义Fragment页面。这种方式这里叫做静态添加方式。有如下解决方式： 直接在Activity中获取的Fragment实例（findViewById）然后将Activity作为中转进行传递参数。 类似的，也可以在Fragemnt中获取activity对象，然后通过findViewById来找到其余的fragment实例，然后进行操作，本质上来说和第一种一样，只是将操作数据代码放置在了自定义Fragment之中。 还可以定义接口，然后在Activity中设置接口的实例。 可以看出这些方式均是通过Activity这个中间人来进行完成的参数传递。这种做法的明显缺点就是代码耦合度比较高，因此不怎么适用。 5.2 动态添加的fragment 在前面提到了，在Android中对Fragment的管理通常使用FragmentManager和FragmentTransaction来管理Fragment之间的切换。那么在这种方式下的Fragment之间参数传递是如何完成的？这里也来回顾一下，参考文档：在 Fragment 之间传递数据 | Android 开发者 | Android Developers (google.cn)。 按照文档描述可以分为两类： | 平级 | 父子级 | | --- | --- | | 数据从Fragment B 发送到 Fragment A |子级 Fragment 发送数据到其父级 Fragment| | | | 5.2.1 平级 从 Fragment 1.3.0-alpha04 开始，每个FragmentManager都会实现 FragmentResultOwner。这意味着 FragmentManager可以充当Fragment结果的集中存储区。此更改通过设置 Fragment结果并监听这些结果，而不要求 Fragment直接引用彼此，让单独的 Fragment相互通信。 假定此时需要AFragment和BFragment通讯，那么需要在AFragment中找到FragmentManager对象，然后通过setFragmentResult传递一个Bundle对象。这里需要使用相同的requestKey在同一FragmentManager上设置结果。 首先是发送数据： class AFragment : Fragment() { private var listener: SwitchListener? = null override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_a, container, false) } override fun onResume() { super.onResume() view?.findViewById(R.id.a_fragment_textView)?.setOnClickListener { Snackbar.make(it, \"正在切换到BFragment\", Snackbar.LENGTH_LONG) .show() // 回调函数 listener?.onClick() // 传递数据到BFragment parentFragmentManager.setFragmentResult(\"requestKey\", Bundle().apply { putString(\"bundleKey\", \"value\") }) } } fun setSwitchListener(l: SwitchListener){ listener = l } } 然后在BFragment中接收： class BFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_b, container, false) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) parentFragmentManager.setFragmentResultListener( \"requestKey\", this, object : FragmentResultListener{ override fun onFragmentResult(requestKey: String, result: Bundle) { view?.let { val string = result.getString(\"bundleKey\") Snackbar.make(it, \"BFragment收到数据内容：${ string }\", Snackbar.LENGTH_LONG) .show() } } } ) } } 至于Activity中就是完成切换Fragment，核心为： supportFragmentManager.beginTransaction() .add(R.id.fragment_container, aFragment) .add(R.id.fragment_container, bFragment) .hide(bFragment) .show(aFragment) .commit() 最终就可以做到将数据从AFragment传递到BFragment。 5.2.2 父子级 如需将结果从子级 Fragment 传递到父级 Fragment，父级 Fragment在调用setFragmentResultListener()时应使用getChildFragmentManager()而不是getParentFragmentManager()。 孩子传递数据： Bundle result = new Bundle(); result.putString(\"bundleKey\", \"result\"); // The child fragment needs to still set the result on its parent fragment manager getParentFragmentManager().setFragmentResult(\"requestKey\", result); 父Fragment 接收： @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // We set the listener on the child fragmentManager getChildFragmentManager().setFragmentResultListener(\"key\", this, new FragmentResultListener() { @Override public void onFragmentResult(@NonNull String key, @NonNull Bundle bundle) { String result = bundle.getString(\"bundleKey\"); // Do something with the result.. } }); } 5.3 其余方式 比如EventBus、ViewModel、文件等方式。当然，在NavController中也提供了一个可传递普通对象的方法： navigate(@IdRes resId: Int, args: Bundle?) 也可以用于参数的传递。 5.4 Navigation的Safe Args 参考文档：在目的地之间传递数据 | Android 开发者 | Android Developers (google.cn) 值得注意的是，文档提到了： 通常情况下，强烈建议您仅在目的地之间传递最少量的数据。例如，您应该传递键来检索对象而不是传递对象本身，因为在Android上用于保存所有状态的总空间是有限的。如果您需要传递大量数据，不妨考虑使用 ViewModel（如在 Fragment之间共享数据中所述）。 也即是：其实Safe Args比较鸡肋。 5.4.1 环境配置 在项目的build.gradle文件中配置： buildscript { repositories { google() } dependencies { val nav_version = \"2.4.2\" classpath(\"androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version\") } } 以及在app模块中添加： plugins { ... id \"androidx.navigation.safeargs\" } 启用 Safe Args后，该插件会生成代码，其中包含您定义的每个操作的类和方法。对于每个操作，Safe Args 还会为每个源目的地（生成相应操作的目的地）生成一个类。生成的类的名称由源目的地类的名称和“Directions”一词组成。例如，如果目的地的名称为SpecifyAmountFragment，生成的类的名称为SpecifyAmountFragmentDirections。生成的类为源目的地中定义的每个操作提供了一个静态方法。该方法会将任何定义的操作参数作为参数，并返回可传递到navigate()的NavDirections对象。 5.4.2 使用 比如在nav_graph.xml中配置一个username参数： 注意到argument定义在action标签下，故而在导航的时候，是通过action来封装和赋值。比如在源Fragment中传递： binding.textView.setOnClickListener { // 方式六：Navigation.findNavController(Activity, @IdRes int viewId) activity?.let { it1 -> // Navigation.findNavController(it1, R.id.nav_host_fragment_container) // .navigate(R.id.action_firstFragment_to_secondFragment3) val action: NavDirections = FirstFragmentDirections.actionFirstFragmentToSecondFragment3(\"李思思\") view?.findNavController()?.navigate(action) } } 在目标Fragment中，直接获取即可： override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val string = arguments?.getString(\"user_name\") Snackbar.make(view, \"${ string }\", Snackbar.LENGTH_LONG) .show() } 但其实这个过程和Bundle类似。 5. 后 由于篇幅原因，拟将接下来的内容放置到下个小节中继续。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"【AndroidJetpack】Navigation——条件导航.html":{"url":"【AndroidJetpack】Navigation——条件导航.html","title":"【AndroidJetpack】Navigation——条件导航","keywords":"","body":"[toc] 1. 前言 拟定在本小节完成条件导航案例。具体逻辑就是： 一共三个Fragment，分别为游客可查看的主页、需要登录后才可查看的详情、以及登录页面。 用户进入主页后，如果点击了跳转到详情页面，就判断用户是否登录。如果没有登录进入登录页面，否则显示详情页面数据。 具体使用技术为Navigation、ViewModel、LiveData。 注：这里用户的登录为模拟，没有请求后台，直接在ViewModel中判断完成。 2. 实现 2.1 基础配置 在nav_graph.xml导航图文件中指定主页和详情页的逻辑跳转关系，如下图： 并在nav_graph.xml中指定开始的目标为homeFragment： 在MainActvity的布局文件中使用ConstraintLayout，并定义一个Fragment的容器，指定为NavHostFragment类型，即： 并指定app:defaultNavHost属性为true，表示NavHostFragment会拦截系统返回按钮；用app:navGraph属性指定导航图文件。为了在能够拦截返回键，这里需要在MainActivity中完成下面两步： 通过NavigationUI来设置拦截的系统返回箭头显示； 通过复写onSupportNavigationUp来响应用户点击事件； 代码如下： class MainActivity : AppCompatActivity() { // NavController对象 private lateinit var navController: NavController override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 1. 通过NavigationUI来设置显示返回箭头 navController = Navigation.findNavController(this, R.id.fragmentContainerView) NavigationUI.setupActionBarWithNavController(this, navController) } // 2. 复写onSupportNavigateUp override fun onSupportNavigateUp(): Boolean { return navController.navigateUp() } } 2.2 页面逻辑 分为三个Fragment页面，首先是在HomeFragment中完成点击后跳转到DetailFragment的监听： // HomeFragment override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val textView = view.findViewById(R.id.homeFragment_textView) textView.setOnClickListener { this.findNavController().navigate(R.id.detailFragment) } } 在DetailFragment中完成用户登录的判断。这里的逻辑为： 使用ViewModel来存储一个LiveData类型的用户对象，进入的时候初始化内容为游客，并且对于这个用户数据类型的LiveData类型注册一个观察。如果当前ViewModel中存储的用户为游客，就跳转向登录页面； 获取当前返回栈的实例，从中获取SavedStateHandle，这个对象用于键值对的形式存储数据，在get和set的时候可以用于设置一个可观察的LiveData。 在LoginFragment中完成用户登录的判断。逻辑为： 和DetailFragment使用同一个ViewModel，在这个ViewModel中添加一个用来存储登录成功或失败的变量，登录成功后，更新用户User以及对应的登录成功与否的标志。 在LoginFragment中注册登录成功与否标志的观察者，如果登录成功，在栈中上一个实例的SavedStateHandle中存储登录成功标志为true。并回退栈。 2.3 代码 2.3.1 UserModel 存储两个变量，分别为用户和登录成功与否标志： class UserViewModel : ViewModel() { var user = MutableLiveData() var loginResult = MutableLiveData() fun login(username: String, password: String){ val flag = (username == \"Name\" && password == \"123\") if(flag) { // 相等在写入 user.value = User(username, password) } loginResult.value = LoginResult(flag) Log.e(\"TAG\", \"login: $flag\") } fun initUser(){ user.value = User(\"游客\", \"123\") } } 2.3.2 LoginFragment 调用ViewModel中的登录判断，注册观察者观察登录成功与否标志。然后根据逻辑完成添加标志以及回退。 class LoginFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_login, container, false) } private lateinit var userViewModel: UserViewModel private var savedStateHandle: SavedStateHandle? = null companion object { const val LOGIN_SUCCESSFUL = \"LOGIN_SUCCESSFUL\" } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) userViewModel = ViewModelProvider(requireActivity(), ViewModelProvider.NewInstanceFactory()) .get(UserViewModel::class.java) // 检索上一个目的地的NavBackStackEntry savedStateHandle = Navigation.findNavController(view) .previousBackStackEntry ?.savedStateHandle // 初始时刻，设置登录状态为false savedStateHandle?.set(LOGIN_SUCCESSFUL, false) // 获取用户输入的数据 val userName = view.findViewById(R.id.editTextTextPersonName) val password = view.findViewById(R.id.editTextTextPassword) val submit = view.findViewById(R.id.submit) submit.setOnClickListener { login(userName.text.toString(), password.text.toString()) } userViewModel.loginResult.observe(viewLifecycleOwner) { Log.e(\"TAG\", \"onViewCreated: 哈哈哈 ${ it?.success }\" ) if (it?.success == true) { savedStateHandle?.set(LOGIN_SUCCESSFUL, true); NavHostFragment.findNavController(this@LoginFragment).popBackStack() Snackbar.make(view, \"登录成功\", Snackbar.LENGTH_LONG) .show() } else { Snackbar.make(view, \"登录失败\", Snackbar.LENGTH_LONG) .show() } } } private fun login(userName: String, passWord: String){ userViewModel.login(userName, passWord) } } 2.3.3 DetailFragment class DetailFragment : Fragment() { private lateinit var userViewModel: UserViewModel override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_detail, container, false) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 可能是登录后的回退到这个页面 Log.e(\"TAG\", \"onCreate: 可能是登录后的回退到这个页面\", ) val navController = NavHostFragment.findNavController(this) // 检索当前的nav val currentBackStackEntry = navController.currentBackStackEntry val savedStateHandle = currentBackStackEntry?.savedStateHandle if (currentBackStackEntry != null) { savedStateHandle?.getLiveData(LoginFragment.LOGIN_SUCCESSFUL) ?.observe(currentBackStackEntry, object : Observer{ override fun onChanged(flag: Boolean?) { if(flag == true) { // 登录成功 val startDestinationId = navController.graph.startDestinationId val navOptions = NavOptions.Builder() .setPopUpTo(startDestinationId, true) .build() navController.navigate(startDestinationId, null, navOptions) } else { // 登录失败，回退到游客页面 NavHostFragment.findNavController(this@DetailFragment).popBackStack() } } }) } } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // 判断用户信息是否为空 userViewModel = ViewModelProvider(requireActivity(), ViewModelProvider.NewInstanceFactory()) .get(UserViewModel::class.java) val findNavController = this.findNavController() userViewModel.user.observe(viewLifecycleOwner) { if (it.name == \"游客\") { findNavController.navigate(R.id.loginFragment) } } // 初始化一个游客身份登录 if(userViewModel.user.value?.name == null) { userViewModel.initUser() } } } 3. 代码地址 代码地址：https://github.com/baiyazi/JetpackNotes/tree/main/project/navi Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"【AndroidJetpack】Navigation——DeepLink.html":{"url":"【AndroidJetpack】Navigation——DeepLink.html","title":"【AndroidJetpack】Navigation——DeepLink","keywords":"","body":"[TOC] 1. 前言 Navigation中的DeepLink又叫做深层链接。在 Android 中，深层链接是指： 将用户直接转到应用内特定目的地的链接。 在日常生活中很容易看见的应用：微信消息通知，点击后直接进入某人或者群聊的界面。借助 Navigation 组件可以比较轻松的完成这个效果。在Navigation 组件中根据其使用方式的不同，可以分为两种不同类型的深层链接：显式深层链接和隐式深层链接。其分类如下面表格所示： | 深层链接 | 说明 | | --- | --- | | 显式深层链接 | 使用 PendingIntent 将用户转到应用内的特定位置。 | | 隐式深层链接 | 通过 URI、intent操作和 MIME类型匹配深层链接。可以为单个深层链接指定多个匹配类型，但请注意，匹配的优先顺序依次是 URI 参数、intent操作和 MIME 类型。 | 从上面的表格中不难看出，深层链接类似于Activity的显式和隐式跳转逻辑。在本小节中将对显式深层链接和隐式深层链接分别进行实践理解。 2. 显式深层链接 2.1 环境 首先还是引入navigation、viewmodel和livedata的依赖： // navigation def nav_version = \"2.4.2\" implementation(\"androidx.navigation:navigation-fragment-ktx:$nav_version\") implementation(\"androidx.navigation:navigation-ui-ktx:$nav_version\") // https://mvnrepository.com/ implementation 'androidx.lifecycle:lifecycle-viewmodel:2.3.1' implementation 'androidx.lifecycle:lifecycle-livedata:2.3.1' 对应的，在res目录下，创建一个navigation类型的xml配置文件（nav_graph.xml）。然后添加AFragment、BFragment、CFragment三个页面，并配置在nav_graph.xml中的行为动作为： 然后，添加返回按钮的支持。即在MainActivity的xml布局文件中添加： app:defaultNavHost=\"true\" 然后在Activity中通过NavigationUI配置显示，最后重写onSupportNavigationUp方法。 ... navController = this.findNavController(R.id.fragmentContainerView) NavigationUI.setupActionBarWithNavController(this, navController) } override fun onSupportNavigateUp(): Boolean { return navController.navigateUp() || super.onSupportNavigateUp() } 然后对应的为每个Fragment的TextView添加到下个页面的点击事件。类似于这种： override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById(R.id.a_fargment_textview).setOnClickListener { Navigation.findNavController(view) .navigate(R.id.action_AFragment_to_BFragment) } } 至此，环境配置完成。 2.2 使用DeepLink 上面的环境配置完毕后，可以达到的效果为AFragment点击文本后可以进入BFragment，点击文本后进入CFragment。那么这里来测试一下，为AFragment添加一个按钮，可以直接进入到CFragment。 前文提到了，显式深层链接是深层链接的一个实例，该实例使用 PendingIntent将用户转到应用内的特定位置。所以这里我们需要构建PendingIntent对象。注意到创建深层链接有两种方式： 使用 NavController.createDeepLink()创建深层链接。 使用 NavDeepLinkBuilder 类构造深层链接。 2.2.1 NavController.createDeepLink() 通过NavController实例对象来创建一个DeepLink，进而可以得到PendingIntent对象。 // 设置PendingIntent val pendingIntent: PendingIntent = this.findNavController().createDeepLink() .setGraph(R.navigation.nav_graph) // 指定导航图 .setDestination(R.id.CFragment) // 去往CFragment .setComponentName(MainActivity::class.java) // 指定Fragment所在的Activity .setArguments(Bundle().apply { // 传递参数 putString(\"Key\", \"Value\") }) .createPendingIntent() 2.2.2 NavDeepLinkBuilder(context) // 设置PendingIntent val pendingIntent: PendingIntent = NavDeepLinkBuilder(requireContext()) .addDestination(R.id.CFragment, Bundle().apply { // 传递参数 putString(\"Key\", \"Value\") }) .setGraph(R.navigation.nav_graph) // 指定导航图 .setComponentName(MainActivity::class.java) // 指定Fragment所在的Activity .createPendingIntent() 2.2.3 完整案例 在AFragment中点击按钮创建一个通知，然后在通知中使用DeepLink： class AFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_a, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById(R.id.a_fargment_textview).setOnClickListener { Navigation.findNavController(view) .navigate(R.id.action_AFragment_to_BFragment) } // 使用参数 if(arguments != null) { Log.e(\"TAG\", \"onViewCreated: ${ requireArguments().getString(\"Key\") }\", ) } view.findViewById(R.id.a_fragment_button).setOnClickListener { // 使用显式深层链接 useExplicitDeepLink() } } private var notificationId = 0 private fun useExplicitDeepLink(){ // 设置PendingIntent val pendingIntent: PendingIntent = this.findNavController().createDeepLink() .setGraph(R.navigation.nav_graph) .setDestination(R.id.CFragment) // 去往CFragment .setComponentName(MainActivity::class.java) .setArguments(Bundle().apply { putString(\"Key\", \"Value\") }) .createPendingIntent() // 创建通知 if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { // 创建一个通知渠道 val notificationChannel = NotificationChannel( activity?.packageName, \"MyChannel\", NotificationManager.IMPORTANCE_DEFAULT ) notificationChannel.description = \"显式深层链接测试\" val notificationManager: NotificationManager? = activity?.getSystemService(NotificationManager::class.java) notificationManager?.createNotificationChannel(notificationChannel) } // 创建Notification val notification = NotificationCompat.Builder( requireActivity(), requireActivity().packageName) .setContentTitle(\"DeepLink\") .setContentText(\"深层链接测试\") .setSmallIcon(R.drawable.ic_launcher_background) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .setContentIntent(pendingIntent) .setAutoCancel(true) .build() val notificationManagerCompat = NotificationManagerCompat.from(requireActivity()) notificationManagerCompat.notify(notificationId++, notification) } } 上面所使用的为第一种创建方式，使用NavController实例来进行创建一个DeepLink进而创建出所需的PendingIntent实例对象。然后将其添加到通知中。当然，也可以使用第二种方式来替换pendingIntent，效果一致，这里不再演示。注意到，在上面的代码中传递了参数，所以可以在目标CFragment中获取，即： override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 获取传递的数据 val string = arguments?.getString(\"Key\").toString() Log.e(\"TAG\", \"onCreate: ${string}\") } 3. 隐式深层链接 在前言中提到了，隐式深层链接是通过 URI、intent操作和 MIME类型匹配深层链接。在实际场景中比如手机浏览网页上的博客，会有“APP打开”的字样用来引导用户使用目标App。如果当前手机并没有安装，会引导至应用市场下载，否则直接打开这个目标应用。而这个功能，就可以使用隐式深层链接。 3.1 配置nav_graph.xml 首先配置一下导航图，为目标Fragment配置deeplink，支持如下配置： 由于uri、action、mimeType可以三选一，故而这里我仅配置了uri方式，如下： 需要注意的是，这里需要指定https://或者http://，后面链接需要加/。然后可以通过两种方式来使用这个隐式深层链接。 3.2 配置声明 需要在应用的manifest.xml文件中添加内容。将一个元素添加到指向现有导航图的 Activity，如以下示例所示： 构建项目时，Navigation 组件会将元素替换为生成的元素，以匹配导航图中的所有深层链接。 3.3 调用 前面提到了，可以有两种方式来启用这个隐式深层链接，分别为应用内、应用外。 3.3.1 应用内使用 也就是同一个应用内。比如在BFragment添加一个Button然后为其添加跳转的响应： view.findViewById(R.id.b_fragment_button).setOnClickListener { // 应用内使用DeepLink。 val request = NavDeepLinkRequest.Builder .fromUri(\"https://github.com/baiyazi/\".toUri()) .build() findNavController().navigate(request) } 运行即可跳转到CFragment页面。 3.3.2 应用外 可以在另一个APP中添加一个超链接，设置链接地址为：https://github.com/baiyazi/。比如直接使用TextView指定： 运行就可以看到一个可点击的链接： 测试分为两种情况： 已经安装 当我们的DeepLink目标应用已经安装后，启动测试带有https://github.com/baiyazi/链接的应用，可以发现： 虽然是一个链接，但是我们的DeepLink目标应用也可以发现。打开后，就是目标CFragment。 未安装 当DeepLink目标应用未安装，这里采用卸载后再次点击。就可以发现打开的仅是链接地址了。 所以，如果放置的是应用市场的链接，就可以引导用于下载目标应用了。 4. 其他 关于隐式深层链接还需要注意两点： 链接可以设置参数；比如：http://www.example.com/users/{id}与http://www.example.com/users/4匹配。 SingleTop模式需要额外处理；使用standard启动模式时，Navigation 会调用handleDeepLink())来处理Intent中的任何显式或隐式深层链接，从而自动处理深层链接。但是，如果在使用备用singleTop等备选launchMode时重复使用了相应Activity，则这不会自动发生。在这种情况下，有必要在onNewIntent()中手动调用handleDeepLink()。如：override fun onNewIntent(intent: Intent?) { super.onNewIntent(intent) navController.handleDeepLink(intent) } 代码地址：https://github.com/baiyazi/JetpackNotes/tree/main/project/deeplink Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:28 "},"Gitbook安装.html":{"url":"Gitbook安装.html","title":"Gitbook安装","keywords":"","body":"1. 安装 安装一个低版本的node，对于多个node的管理可以使用nvm工具。涉及到的两个命令为： nvm list [available] nvm use [version] [arch] 比如当前我的版本为： 如果需要指定其余的版本，可以使用： nvm install 16.13.0 来进行安装，如果需要知道版本号，可以使用： nvm ls available 来进行查看。这里我安装： >nvm install 8.11.1 切换版本： >nvm use 8.11.1 但很不幸这个版本在阿里镜像中没有npm，所以换为8.17.0，详细的node版本和对应的npm版本对应关系链接：以往的版本 | Node.js (nodejs.org)。 然后使用npm命令安装gitbook： >npm install gitbook-cli -g 然后指定安装版本： >gitbook fetch 2.6.7 使用>gitbook -V可查看当前版本： 其他命令： gitbook ls-remote： 列出可供安装的远程版本 2. 使用 然后在自己所在的项目目录下，初始化项目，使用命令： gitbook init 初始化完毕后，生成两个文件： 最后的文档就是在同一个目录中写作完成即可。生成和运行使用： gitbook serve 结果： 打开对应的链接可以访问到结果。即： 且对应的本地生成了静态网页文件： 值得高兴的一件事情就是，在看云平台下载的git文档刚好满足条件。比如，以我的Jetpack笔记为例，下载下来为： 3. 配置 对于gitbook的相关操作可以查阅文档：搜索 | GitBook文档（中文版） (gitbooks.io) 在book.json文件中，可以做一些简单的配置，可以参考这篇博客：GitBook-如何安装？介绍book.json的实用配置和插件，弹出查看大图_你知不知的博客-CSDN博客 这里我配置如下： { \"title\": \"Jetpack\", \"author\": \"梦否\", \"description\": \"This is such a great book!\", \"language\": \"zh-hans\", \"direction\": \"rtl\", \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" }, \"plugins\": [ \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\", \"popup\", \"page-treeview\", \"code\", \"chapter-fold\", \"tbfed-pagefooter\", \"splitter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy 梦否 2019\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"page-treeview\": { \"copyright\": \"Copyright &#169; 梦否\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" } } } 还可以添加自己的博客链接，GIthub链接等： \"links\": { \"sidebar\": { \"Blog\": \"https://mengfou.blog.csdn.net/\", \"Github\": \"https://github.com/baiyazi\" } } 配置好后，使用： gitbook install 来安装插件，安装完毕后，使用： >gitbook serve 生成新的静态文件。 一些额外功能。可以参考博客：Gitbook 插件和主题 | Dastone's Notes (szdastone.github.io) 关于其插件，可以参考：插件 · GitBook 使用教程 (zhangjikai.com)、GitBook 常用插件 - 走看看 (zoukankan.com) 3.1 目录配置 \"theme-default\": { \"showLevel\": true } 将 showLevel 设为 true，这样就会显示标题前面的数字索引，默认是不显示的。 3.2 主题 \"plugins\": [ \"theme-comscore\" ] comscore 可以为标题增加颜色，而缺省主题都是黑白色的。 4. 发布 首先需要先安装 gh-pages: >npm i gh-pages -g 然后使用: >gitbook build 编译一下，确保目录下有_book目录。然后上传文件到github，这里新建一个. gitignore文件，配置： \\*~ node\\_models/\\* 然后在github新建一个JetpackNotes仓库，这里为了方便我在本地使用gitDesktop打开，然后进行操作管理。将源码上传到Master分支，将生成的_book上传到gh-pages 分支。需要注意的是html-pages分支确保放置HTML文件。 比如，我这里仓库为：https://github.com/baiyazi/JetpackNotes/ 然后在设置中进行发布： 当然，也可以直接查看项目中的一些配置。这里不再继续介绍。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-05-01 19:16:27 "}}