{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 【Android Jetpack】LifeCycle 数据存储 DataStore 视图绑定 数据绑定 【Android Jetpack】Room——基本使用 【Android Jetpack】Livedata 【Android Jetpack】Room+ViewModel+LiveData 【Android Jetpack】Room——其余 【Android Jetpack】Room——多表之间的关系 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-27 15:09:45 "},"Jetpack之LifeCycle.html":{"url":"Jetpack之LifeCycle.html","title":"【Android Jetpack】LifeCycle","keywords":"","body":"[TOC] 1. 说明 LifeCycle它持有组件的生命周期状态信息，主要用于Activity、Fragment、Service和Application的生命周期管理，其他类可以观察到这些状态，进而有利于代码的解耦。而且在配置更改后可以轻松避免内存泄漏，以及将数据加载到界面中。 比如在Activity 生命周期的状态和事件： 2. Lifecycle 在Lifecycle中存在两类角色： 具有生命周期的组件，比如Activity、Fragment、Service 等任何具有生命周期的组件，通常被称为LifecycleOwner，也即是被观察者。 LifecycleObserver，即观察者，需要感知生命周期方法。 很明显，也就是观察者模式。由于在上述组件中已经实现了LifecycleObserver接口，比如在Activity中： public class ComponentActivity extends androidx.core.app.ComponentActivity implements ContextAware, LifecycleOwner, ... 并实现了其getLifecycle方法，故而在观察者模式中被观察者已经由系统实现，我们所需要做的也就是实现观察者类，也即是自定义类，实现LifecycleObserver接口，然后设置观察即可。 2.1 LifecycleObserver 而该接口又只是一个空接口，即仅用作标识： public interface LifecycleObserver { } 2.2 LifecycleOwner LifecycleOwner 是一个接口，用来表示类具有Lifecycle。其声明如下： public interface LifecycleOwner { @NonNull Lifecycle getLifecycle(); } 可以看见只有一个方法，也就是getLifecycle()， 可以通过调用Lifecycle类的addObserver()方法并传递观察器的实例来添加观察器，比如下面的代码： class MyObserver : DefaultLifecycleObserver { override fun onResume(owner: LifecycleOwner) { connect() } override fun onPause(owner: LifecycleOwner) { disconnect() } } myLifecycleOwner.getLifecycle().addObserver(MyObserver()) 3. 案例 比如下面的案例： 3.1 案例一：使用LifeCycle解耦页面组件 学习视频地址：LifeCycle 不使用LifeCycle的时候，通过Chronometer计时器来做一个简单的计时操作，满足下面条件： 当Activity可见的时候，继续计时； 当Activity不可见的时候，且还没有被Destory的时候，就暂停当前计时； 3.1.1 借助生命周期方法 class MainActivity : AppCompatActivity() { // 继承自TextView的一个计时器类 private lateinit var chronometer: Chronometer override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) chronometer = findViewById(R.id.chronometer) } private var elapsedtime = 0L // 可见 override fun onResume() { super.onResume() // 设置计时器的起始时间为“当前”系统时间 // SystemClock.elapsedRealtime() 从设备开机到现在的时间 chronometer.base = SystemClock.elapsedRealtime() - elapsedtime chronometer.start() } // 不可见 override fun onStop() { super.onStop() elapsedtime = SystemClock.elapsedRealtime() - chronometer.base chronometer.stop() } } 上面设置chronometer.base，主要是用于设置计时器的“当前起始时间”，主要是为了确保暂停后开始的基准时间可以略过中间暂停事件，确保计时器在Activity可见后可以连续计时。但是，很显然，这样多余了很多额外的周期函数方法，使用比较麻烦。而使用LifeCycle可以对其进行最大程度简化。而且在组件化开发中，基本的原则就是：能不麻烦别人的事情就尽量自己做。需要暴露更少的方法来完成其功能。 3.1.2 借助LifeCycle 首先封装一下Chronometer这个类，声明其实现了LifecycleObserver接口： class MyChronometer: Chronometer, LifecycleObserver { constructor(context: Context?) : super(context) constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) private var elapsedtime = 0L @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun startChronometer(){ // 设置计时器的起始时间为“当前”系统时间 base = SystemClock.elapsedRealtime() - elapsedtime start() } @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stopChronometer(){ elapsedtime = SystemClock.elapsedRealtime() - base stop() } } 将前面案例中的代码添加到其中，并为其指定了对应的Lifecycle事件方法。对应的将xml中修改为我们自定义的MyChronometer类，然后调用： class MainActivity1 : AppCompatActivity() { // 继承自TextView的一个计时器类 private lateinit var chronometer: MyChronometer override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) chronometer = findViewById(R.id.chronometer) // 为Activity的lifecycle添加一个监听 lifecycle.addObserver(chronometer) } } 就可以看见一样满足要求的计时器。这两个案例做一个简单的对比，很明显第二种写法更加利于系统组件和普通组件的代码解耦。这里可以总结一下上面的使用流程： 自定义一个类，实现了LifecycleObserver接口； 在Activity或者Fragment中进行添加观察者，以监听对应的生命周期函数； 3.2 案例二：使用LifeCycleService解耦Service组件 视频地址：https://www.bilibili.com/video/BV1Ry4y1t7Tj?p=3&t=863.3 该案例以模拟获取GPS为案例，具体为在后台开启一个Service，然后在这个Service中注册观察者对象，在这个观察者对象中可以观察到Activity的onStart、onStop等事件。也就可以自动完成进入这个Activity就开始获取地理位置的更新，退出这个Activity就停止获取位置。 3.2.1. 基础版本 如果获取用户地理位置的功能没有独立封装为一个组件，那么我们如果需要考虑页面声明周期，那么就需要按照下面的形式，因为非自定义组件并不能主动感知声明周期的变化。 class LocationActivity: AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_location ) } override fun onResume() { super.onResume() // 开始获取用户地理位置 startGetLocation() } override fun onPause() { super.onPause() // 停止获取 stopGetLocation() } } 3.2.2. 使用Service 上面的第一种方式明显的缺点就是耦合度很高，所以为了减少耦合度，而又不影响对生命周期的监听，就可以使用LifeCycle来进行改写。故而我们可以自定义一个类，然后使用LifecycleObserver来标识这个类为LifeCycle的一个观察者类，在这个类中完成自定义控件，即具体功能。 class MyLocationObserver(context: Context): LifecycleObserver { private var mCtx : Context = context private lateinit var myLocationListener: MyLocationListener private lateinit var locationManager: LocationManager @OnLifecycleEvent(Lifecycle.Event.ON_START) private fun startGetLocation(){ Log.e(\"TAG\", \"startGetLocation: \") // 获取LocationManager locationManager = mCtx.getSystemService(Context.LOCATION_SERVICE) as LocationManager // 权限 if (ActivityCompat.checkSelfPermission( mCtx, Manifest.permission.ACCESS_FINE_LOCATION ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission( mCtx, Manifest.permission.ACCESS_COARSE_LOCATION ) != PackageManager.PERMISSION_GRANTED ) { return } // 添加监听 myLocationListener = MyLocationListener() locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3000, 2f, myLocationListener) } inner class MyLocationListener: LocationListener{ override fun onLocationChanged(location: Location) { Log.e(\"TAG\", \"onLocationChanged: ${ location }\" ) } } @OnLifecycleEvent(Lifecycle.Event.ON_STOP) private fun stopGetLocation(){ Log.e(\"TAG\", \"stopGetLocation: \", ) // 移除 locationManager.removeUpdates(myLocationListener) } } 当页面生命周期发生变化时，这些使用@OnLifecycleEvent标识过的方法便会被自动调用。那么在调用的时候，由于Activity或者Service均已经实现了被观察者LifecycleOwner的接口，故而这里直接调用实现这个接口的getLifecycle方法，得到Lifecycle对象，然后添加观察者： lifecycle.addObserver(MyLocationObserver(this)) 注意到，本小节的标题为使用Service，这里我们可以使用比较经典的写一个类继承自Service，根据自己所使用的启动方式，即startService或者bindService来复写对应的onStartCommand或者onBind方法。然后在Activity中进行startService或者bindService。比如： class MyService: LifecycleService() { private var _observer: MyLocationObserver = MyLocationObserver(this) init { lifecycle.addObserver(_observer) } override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Log.e(\"TAG\", \"onStartCommand: \") // 注册观察者 val myLocationObserver = MyLocationObserver(this) lifecycle.addObserver(myLocationObserver) return super.onStartCommand(intent, flags, startId) } override fun onDestroy() { super.onDestroy() lifecycle.removeObserver(_observer) } } 然后在主Activity中启动服务： class LocationActivity: AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_location ) // 启动服务 startService(Intent().apply { setClass(this@LocationActivity, MyService::class.java) }) } } 运行可以看见结果： 然后可以使用adb devices查看一下设备： 然后可以使用adb命令修改模拟位置： adb -s emulator-5554 emu geo fix 101.49612 41.24010 就可以发现日志进行了更新： 3.3. 案例三：监听应用程序的生命周期 在LifeCycle中提供了ProcessLifecycleOwner来实现监听应用程序的声明周期。同样的，这里还是自定义一个类，继承自LifecycleObserver： class MyApplicationObserver : LifecycleObserver { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) private fun onCreate() { Log.e(\"TAG\", \"application onCreate.\") } @OnLifecycleEvent(Lifecycle.Event.ON_START) private fun onStart() { Log.e(\"TAG\", \"application onStart.\") } @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) private fun onResume() { Log.e(\"TAG\", \"application onResume.\") } } 然后在Activity中使用： class LocationActivity: AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_location ) // 添加应用程序生命周期观察者对象 ProcessLifecycleOwner.get().lifecycle.addObserver(MyApplicationObserver()) } } 就可以监听到应用程序的生命周期变化。 ProcessLifecycleOwner是针对整个应用程序的监听，与Activity数量无关； Lifecycle.Event.ON_CREATE只会被调用一次，而Lifecycle.Event.ON_DESTROY永远不会被调用。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"DataStore.html":{"url":"DataStore.html","title":"DataStore","keywords":"","body":"[TOC] 1. 前言 Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore使用Kotlin 协程和Flow 以异步、一致的事务方式存储数据。如果您当前在使用SharedPreferences存储数据，请考虑迁移到 DataStore。如果您需要支持大型或复杂数据集、部分更新或参照完整性，请考虑使用Room，而不是 DataStore。 2. 分类 DataStore 提供两种不同的实现：Preferences DataStore和 Proto DataStore。 Preferences DataStore使用键值对存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。DataStore 是基于 Flow 实现的，不会阻塞主线程。只支持Int,Long,Boolean,Float,String键值对数据，适合存储简单、小型的数据，并且不支持局部更新，如果修改了其中一个值，整个文件内容将会被重新序列化。 Proto DataStore将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。 Proto DataStore使用协议缓冲区来定义架构。使用协议缓冲区可持久保留强类型数据。与 XML 和其他类似的数据格式相比，协议缓冲区速度更快、规格更小、使用更简单，并且更清楚明了。虽然使用 Proto DataStore 需要学习新的序列化机制，但我们认为 Proto DataStore 有着强大的优势，值得学习。 2.1 Preferences DataStore 和SharedPreferences的区别 SharedPreferences 有一个看上去可以在界面线程中安全调用的同步API，但是该 API 实际上执行磁盘 I/O 操作。此外，apply()会阻断fsync()上的界面线程。每次有服务启动或停止以及每次 activity 在应用中的任何地方启动或停止时，系统都会触发待处理的fsync()调用。界面线程在apply()调度的待处理fsync()调用上会被阻断，这通常会导致ANR。 3. 实践 3.1 Preferences DataStore 3.1.1 依赖 // DataStore Preferences implementation(\"androidx.datastore:datastore-preferences:1.0.0\") // optional - RxJava2 support implementation(\"androidx.datastore:datastore-preferences-rxjava2:1.0.0\") // optional - RxJava3 support implementation(\"androidx.datastore:datastore-preferences-rxjava3:1.0.0\") 3.1.2 案例 下面案例来源于官网案例，地址：DataStore | Android 开发者 | Android Developers (google.cn)。 class MainActivity2 : AppCompatActivity() { // 创建一个DataStore，并申明在顶层以方便调用 private val Context.dataStore: DataStore by preferencesDataStore(name = \"settings\") // 声明一个int类型的key val EXAMPLE_COUNTER = intPreferencesKey(\"example_counter\") private val textView: TextView by lazy { findViewById(R.id.text) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } // 两个按钮的监听事件 fun buttonOnClick(view: View){ runBlocking { launch { when(view.id){ R.id.update -> { incrementCounter() } R.id.read -> { textView.text = getData().toString() } } } } } // 存储-自增1 suspend fun incrementCounter() { dataStore.edit { settings -> val currentCounterValue = settings[EXAMPLE_COUNTER] ?: 0 settings[EXAMPLE_COUNTER] = currentCounterValue + 1 } } // 获取当前值 suspend fun getData(): Int { return dataStore.data.map { settings -> settings[EXAMPLE_COUNTER] ?: 0 }.first() } } 结果： 3.1.3 最后 在前面提到了，这种类型的Preferences DataStore还支持的数据类型有：Long,Boolean,Float,String等，不妨看看对应的声明函数： longPreferencesKey() booleanPreferencesKey() floatPreferencesKey() stringSetPreferencesKey() 对应的，随便找一个方法，看下是如何实现的： @JvmName(\"longKey\") public fun longPreferencesKey(name: String): Preferences.Key = Preferences.Key(name) 也就是其实底层也还是使用Preferences.Key来指明类型。和SP类似数据内容也存储在本地磁盘data/data/packagename/中： 3.2 Proto DataStore 对于Preferences DataStore中的键只能为上述指定的类型，故而如果我们需要存储自定义对象的数据的时候，就显得力不从心了。故而在jetpack中提供了Proto DataStore。 3.2.1 依赖 引入datastore的依赖： implementation(\"androidx.datastore:datastore:1.0.0\") // optional - RxJava2 support implementation(\"androidx.datastore:datastore-rxjava2:1.0.0\") // optional - RxJava3 support implementation(\"androidx.datastore:datastore-rxjava3:1.0.0\") 为了使用 Proto DataStore，让协议缓冲区为我们的架构生成代码，我们需要对 build.gradle 文件进行一些更改： 3.2.1.1 添加协议缓冲区插件 plugins { ... id \"com.google.protobuf\" version \"0.8.12\" } 3.2.1.2 配置协议缓冲区 implementation \"com.google.protobuf:protobuf-javalite:3.10.0\" 在dependencies平级添加： protobuf { protoc { artifact = \"com.google.protobuf:protoc:3.10.0\" } // Generates the java Protobuf-lite code for the Protobufs in this project. See // https://github.com/google/protobuf-gradle-plugin#customizing-protobuf-compilation // for more information. generateProtoTasks { all().each { task -> task.builtins { java { option 'lite' } } } } } 3.2.2 定义架构 在app/src/main/目录下创建proto目录，然后创建一个xxx.proto文件： testDemo.proto文件内容： syntax = \"proto3\"; // 声明proto的版本 // 定义生成的类的包名 option java_package = \"com.weizu.jetpackdemo.proto\"; // 声明的是内部类MyProtoBean, 格式: 类型+字段名称+字段编号 message MyProtoBean { int32 _id = 1; string _name = 2; int32 _age = 3; bool _isMan = 4; } 至于更加详细的解释可以查阅：protobuf 语言指南以及使用 Proto DataStore (google.cn) 然后Build一下，就可以看到生成的文件： 打开文件可以看到在该文件中生成了配置中对应的message类，和对应的set/get方法： 至此环境配置完毕，接着开始简单使用。 3.2.3 简单使用 3.2.3.1 创建序列化器 我们需要实现序列化器，以告知 DataStore 如何读取和写入我们在 proto 文件中定义的数据类型。如果磁盘上没有数据，序列化器还会定义默认返回值。 object MyBeanSerializer: Serializer { override val defaultValue: TestDemo.MyProtoBean get() = TestDemo.MyProtoBean.getDefaultInstance() override suspend fun readFrom(input: InputStream): TestDemo.MyProtoBean { try { return TestDemo.MyProtoBean.parseFrom(input) } catch (exception: InvalidProtocolBufferException) { throw CorruptionException(\"Cannot read proto.\", exception) } } override suspend fun writeTo(t: TestDemo.MyProtoBean, output: OutputStream) { t.writeTo(output) } } 3.2.3.2 数据存储和读取 /** * @author 梦否 on 2022/3/28 * @blog https://mengfou.blog.csdn.net/ */ class MainActivity2 : AppCompatActivity() { private val textView: TextView by lazy { findViewById(R.id.text) } private val dataStore: DataStore by lazy { DataStoreFactory.create( produceFile = { applicationContext.dataStoreFile(\"user_prefs.pb\") }, serializer = MyBeanSerializer ) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } private var i = 0 // 按钮监听函数 fun buttonOnClick(view: View) { runBlocking { launch { when (view.id) { R.id.update -> { storeData(1 + i, 20 + i, true, \"张三${i}\") i++ } R.id.read -> { val first = readData().first() Log.e(\"TAG\", \"id：${first.id}\") Log.e(\"TAG\", \"age：${first.age}\") Log.e(\"TAG\", \"isMan：${first.isMan}\") Log.e(\"TAG\", \"name：${first.name}\") } } } } } // 读取数据时处理异常 private fun readData(): Flow { return dataStore.data .catch { exception -> // dataStore.data throws an IOException when an error is encountered when reading data if (exception is IOException) { Log.e(\"TAG\", \"Error reading sort order preferences.\", exception) emit(TestDemo.MyProtoBean.getDefaultInstance()) } else { throw exception } } } // 添加数据 private suspend fun storeData(id: Int, age: Int, isMan: Boolean, name: String) { dataStore.updateData { preferences -> preferences.toBuilder() .setAge(age) .setId(id) .setIsMan(isMan) .setName(name) .build() } } } 结果： 每次插入数据都会覆盖掉以前的数据，也就是在使用对象存储数据的时候，只能存储一条数据。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"视图绑定.html":{"url":"视图绑定.html","title":"视图绑定","keywords":"","body":"[TOC] 1. 说明 视图绑定在大多数情况下，视图绑定会替代findViewById。而其实我们自己也可以定义一些注解，通过反射来完成对应的findViewById工作，比如Xutils和ButterKnife中都提供了这个功能。使用的时候比较简单，比如： @BindView(R.id.id_test) TextView tvTest; 但是上面两种使用注解及反射方式的查找控件实例的方式本质上都是调用findViewById自身。Google在Jetpack中推出视图绑定，首先看看二者有何不同。 1.1 与 findViewById 的区别 Null 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用@Nullable标记。 类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。 2. 使用 2.1 环境配置 首先检查一下Android Studio的版本，视图绑定在Android Studio 3.6 Canary 11 及更高版本中可用。 要在某个模块中启用视图绑定，请将viewBinding元素添加到其build.gradle文件中，如下例所示： android { ... viewBinding { enabled = true } } 如果您希望在生成绑定类时忽略某个布局文件，请将tools:viewBindingIgnore=\"true\"属性添加到相应布局文件的根视图中： ... 2.1 用法 为某个模块启用视图绑定功能后，系统会为该模块中包含的每个 XML 布局文件生成一个绑定类。每个绑定类均包含对根视图以及具有 ID 的所有视图的引用。系统会通过以下方式生成绑定类的名称：将 XML 文件的名称转换为驼峰式大小写，并在末尾添加“Binding”一词。 例如，假设某个布局文件的名称为result_profile.xml： 所生成的绑定类的名称就为ResultProfileBinding。此类具有两个字段：一个是名为name的TextView，另一个是名为button的Button。该布局中的ImageView没有 ID，因此绑定类中不存在对它的引用。 每个绑定类还包含一个getRoot()方法，用于为相应布局文件的根视图提供直接引用。在此示例中，ResultProfileBinding类中的getRoot()方法会返回LinearLayout根视图。 2.1.1 在 Activity 中使用视图绑定 请在 Activity 的onCreate()方法中执行以下步骤： 调用生成的绑定类中包含的静态inflate()方法。此操作会创建该绑定类的实例以供 Activity 使用。 通过调用getRoot()方法或使用Kotlin 属性语法获取对根视图的引用。 将根视图传递到setContentView()，使其成为屏幕上的活动视图。 private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // R.layout.activity_main // ViewBinding binding = ActivityMainBinding.inflate(layoutInflater) val rootView = binding.root setContentView(rootView) // TextView -> id=@+id/textView binding.textView // Button -> id=@+id/update binding.update } 2.1.2 在 Fragment 中使用视图绑定 请在 Fragment 的onCreateView()方法中执行以下步骤： 调用生成的绑定类中包含的静态inflate()方法。此操作会创建该绑定类的实例以供 Fragment 使用。 通过调用getRoot()方法或使用Kotlin 属性语法获取对根视图的引用。 从onCreateView()方法返回根视图，使其成为屏幕上的活动视图。 class BlankFragment : Fragment() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) } private var binding: FragmentBlankBinding? = null override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { // R.layout.fragment_blank binding = FragmentBlankBinding.inflate(inflater, container, false) val rootView = binding?.root return rootView } override fun onDestroy() { super.onDestroy() binding = null } } Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"数据绑定.html":{"url":"数据绑定.html","title":"数据绑定","keywords":"","body":"[TOC] 1. 说明 本篇博客参考Data Binding in Android (google.cn) 和 数据绑定库 数据绑定可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。其实有点类似于MVVM框架，数据和显示的部分动态绑定，当数据发生改变对应的视图也随之改变。如果您使用数据绑定的主要目的是取代findViewById()调用，请考虑改用视图绑定。其模式示意图： 和视图绑定类似，对于Android Studio的版本也有要求： Android Studio 3.4 or greater 2. 使用 2.1 环境准备 类似的，直接在配置文件中添加： android { ... dataBinding { enabled = true } } 将之前的layout布局文件修改为DataBinding layout。直接右击根布局的标签元素，然后选择Show Context Actions： 然后就可以看见提供了直接转换到data binding布局的选项： 比如我这里转换后的xml布局文件为： 在data标签中的内容，也就是定义的变量。比如可以定义如下的两个变量： 因为后续需要使用View，所以这里需要导入包。对应的，可以使用自定义的类，然后导入对应的包即可。 2.2 根据name长度显示Message案例 将定义的变量和布局文件中的控件关联，也就是使用变量。在Android Jetpack中定义的使用方式为@{ expression }的格式，也就是可以如下使用： 3) ? View.VISIBLE : View.GONE }\" ... /> 然后就是在代码中设置在xml中申明的两个变量的值。和viewbinding类似在databinding中也需要在onCreate方法替换： setContentView(R.layout.plain_activity) 这里替换为： binding = DataBindingUtil.setContentView( this, R.layout.activity_main ) 所获得的binding对象也就是和布局文件相关联的类，即：ActivityMainBinding。通过binding这个实例，就能够直接操作在xml中声明的变量： binding.name = \"testDemo\" binding.message = \"Hello data binding.\" 完整代码： class MainActivity2 : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 1. setContentView(R.layout.plain_activity) replace with below: // data binding binding = DataBindingUtil.setContentView( this, R.layout.activity_main ) // 2. set the variable values binding.name = \"testDemo\" binding.message = \"Hello data binding.\" } } 结果： 2.3 响应点击事件 通常我们可以直接在xml中直接设置点击函数，比如： android:onClick=\"onButtonClick\" 然后在Activity中定义方法onButtonClick。或者直接通过这个按钮的实例对象来注册监听，进行事件处理。这里也是类似，可以在xml中采用Lambda表达式的方式来注册函数。首先定义一个SimpleViewModel类，继承自ViewModel类，如下： /** * @author 梦否 on 2022/3/29 * @blog https://mengfou.blog.csdn.net/ */ class SimpleViewModel: ViewModel() { // 定义消息 var message = \"Hello data binding.\" get() { return if(clickNumber % 2 == 0) \"偶数\" else \"奇数\" } private set // 阻止外部修改，只支持内部修改 val name = \"testDemo\" var clickNumber = 0 private set // 定义点击函数 fun onTextViewClick(){ clickNumber++ Log.e(\"TAG\", \"onTextViewClick: ${clickNumber}\" ) } } 但是，很不幸，点击TextView之后，在TextView中显示的文本并没有观测到数据的变化。观察日志： 其实，这是因为我们设置的数据并不可观测。我们需要让数据可以observable才行。为了让字段可观测，可以使用observable类或者LiveData。关于可观察的数据对象在Google中有详细说明：使用可观察的数据对象。 2.4 可观察数据类型 可观察类有三种不同类型：对象、字段和集合。 2.4.1 可观测对象 实现Observable接口的类允许注册监听器，以便它们接收有关可观察对象的属性更改的通知。为便于开发，数据绑定库提供了用于实现监听器注册机制的BaseObservable类。实现BaseObservable的数据类负责在属性更改时发出通知。具体操作过程是向 getter 分配Bindable注释，然后在 setter 中调用notifyPropertyChanged()方法。 2.4.2 可观测字段 ObservableField() 以及基本的： 2.4.3 可观察集合 ObservableArrayMap、ObservableArrayList等。 2.5 设置数据可观察 因为这里所使用的为基本类型，比如message和name。由于这里我只需要message可观测，所以这里对其应用可观测字段即可。如下： /** * @author 梦否 on 2022/3/29 * @blog https://mengfou.blog.csdn.net/ */ class SimpleViewModel : ViewModel() { // 定义可观测的字段，使用ObservableField var message = ObservableField(\"Hello data binding.\") private set // 阻止外部修改，只支持内部修改 val name = \"testDemo\" var clickNumber = 0 private set // 定义点击函数 fun onTextViewClick() { clickNumber++ if (clickNumber.rem(2) == 0) message.set(\"is Even\") else message.set(\"is odd\") Log.e(\"TAG\", \"onTextViewClick: ${clickNumber}\") } } 对应的修改在xml中的标签中的变量声明： 对应的MainActivity文件： class MainActivity2 : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 1. setContentView(R.layout.plain_activity) replace with below: // data binding binding = DataBindingUtil.setContentView( this, R.layout.activity_main ) // set data binding.viewModel = SimpleViewModel() } } 然后就可以看见点击后奇数点击和偶数点击的切换显示文本效果。 2.6 数据双向绑定 在这个案例中需要达到的效果为：对应定义的可观测字段Field内容的改变可以通知到对应的控件，而控件的内容变化也可以通知到Field。所以这里可以使用控件EditText。 2.6.1 方式一：继承自BaseObservable 在布局文件中定义一个EditText和TextView，如下： 值得注意的是，在EditText中设置为： android:text=\"@={ myViewModel.userInput }\" 而在TextView中为： android:text=\"@{ myViewModel.userInput }\" 因为在EditText中我们需要完成双向绑定，即用户输入可以通知到LiveData，而在TextView中只要加载变化后的数据即可。 那么，在自定义ViewModel中为： /** * @author 梦否 on 2022/4/20 * @blog https://mengfou.blog.csdn.net/ */ class MyViewModel :BaseObservable(){ // 设置为LiveData，便于布局文件中TextView内容的自动更新 private val userInput = MutableLiveData(\"Tom\") // 这里一定不要忘记添加注解@Bindable，否则双向绑定不会生效 @Bindable @JvmName(\"getUserInput\") fun getUserInput(): String{ return userInput.value.toString() } // 用于更新TextView fun get(): LiveData { return this.userInput } @JvmName(\"setUserInput\") fun setUserInput(str: String){ if(!str.equals(userInput)) { this.userInput.value = str } Log.e(\"TAG\", \"setValue: ${str}\" ) // 通知数据发生了改变 notifyPropertyChanged(BR.myViewModel) // build后会自动生成一个BR类，对应在xml中声明的变量 } } 这里为了完成双向绑定，继承自BaseObservable，且在get方法上使用了@Bindable注解来表示绑定。至于get()方法仅是为了返回LiveData对象，然后在Activity中设置观察，更新TextView控件内容： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main2 ) // 这里直接使用new一个对象 // 因为这里的自定义ViewModel继承的是BaseObservable类，不是ViewModel类 val myViewModel = MyViewModel() binding.myViewModel = myViewModel // 设置观察，以更新TextView文本 myViewModel.get().observe(this) { binding.textView2.text = myViewModel.get().value } } } 效果： 2.6.2 方式二：继承自ObservableField 布局文件还是保持不变： 对于ViewModel进行删减： class MyViewModel { // 设置为可观察类型 val userInput = ObservableField(\"Tom\") } 最后在Activity中进行设置数据： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main2 ) // 这里直接使用new一个对象 // 因为这里的自定义ViewModel继承的是BaseObservable类，不是ViewModel类 val myViewModel = MyViewModel() binding.myViewModel = myViewModel // 在xml文件：@=操作符进行双向绑定 } } 达到的效果和上小节一样。 2.7 RecyclerView+dataBinding 可以使用databinding来设置每个item的内容。比如在主布局文件： 因为使用了RecyclerView，所以这里还是定义对应的适配器： /** * @author 梦否 on 2022/4/20 * @blog https://mengfou.blog.csdn.net/ */ class MyRecycleViewAdapter(var context: Context, var datas: List) : RecyclerView.Adapter() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder { val inflater = LayoutInflater.from(context) val binding = DataBindingUtil.inflate( inflater, R.layout.recyclerview_item, parent, false ) val myViewHolder = MyViewHolder(binding.root) myViewHolder.binding = binding return myViewHolder } override fun onBindViewHolder(holder: MyViewHolder, position: Int) { holder.binding?.user = datas[position] Log.e(\"TAG\", \"onBindViewHolder: ${position} + ${ datas[position].name }\") } override fun getItemCount(): Int { return datas.size } inner class MyViewHolder(var root: View) : RecyclerView.ViewHolder(root) { var binding: RecyclerviewItemBinding? = null } } 同样的在R.layout.recyclerview_item布局文件中设置databinding： 对于User类比较简单： class User(var age: Int, var name: String) { var image = \"https://i1.hdslb.com/bfs/face/7e72c58637ff26df68fb30939de078d2bbbfcdbe.jpg\" } 在主Activity中配置： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main3 ) val datas = listOf( User(12, \"Jack\"), User(10, \"Tom\"), User(23, \"Joe\") ) // 必须设置布局管理器，否则不会显示RecyclerView binding.recyclerView.layoutManager = LinearLayoutManager(this) binding.recyclerView.adapter = MyRecycleViewAdapter(this, datas) } } 运行即可看见效果。 3. 自定义BindingAdapter 参考视频地址：https://www.bilibili.com/video/BV1Ry4y1t7Tj?p=12 这个案例感觉比较典型，达到的效果为可以使用databinding的方式传入一个图片的链接地址，然后可以通过注解的方式来直接定义属性字段。然后可以完成加载。比如下面的案例： 布局文件： 注意到，在ImageView标签中直接设置了自定义的字段： app:imageSrc=\"@{ src }\" 而这个字段以前我们是需要使用tool:并定义对应的styleable样式。这里并不需要，仅需要使用注解来申明： class ImageViewCus { // 需要注意的是，这里需要使用静态方法 companion object{ @JvmStatic @BindingAdapter(\"app:imageSrc\") fun loadImage(imageView: ImageView, str: String){ Glide.with(imageView.context) .load(str) .placeholder(R.drawable.ic_launcher_background) .into(imageView) } } } 最后是在Activity中使用： class MyBindingAdapterActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_binding_adapter ) binding.src = \"https://img-blog.csdnimg.cn/5690c131d90e460fa4c96bf86b1ae634.png\" } } 传入databinding中声明的字符串即可，就可以达到预期的效果。整体的使用流程感觉和SpringBoot中的类似，但是这里比较好奇的是难道这里也会扫描所有包/类中的注解？应该是的，等储备知识够了再深入。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"【AndroidJetpack】Room.html":{"url":"【AndroidJetpack】Room.html","title":"【Android Jetpack】Room——基本使用","keywords":"","body":"[toc] 1. 前言 当然，我们所使用的就是之前使用过的SQLite数据库。可以简单回顾一下在java中是如何操作数据库的： 继承自SQLiteOpenHelper类，复写对应的方法，可以得到一个Helper实例； 通过SQLiteOpenHelper的实例的getWritableDatabase()来得到一个数据库实例； 然后就可以通过这个数据库实例进行CRUD操作； 简单回顾一下在Java中的流程： // 构建一个子类Helper public class MySQLiteOpenHelper extends SQLiteOpenHelper { private Context context; private String name; private String bookSql = \"create table Book (id integer primary key autoincrement, \" + \"name text, pages integer)\"; private String userSql = \"create table User (name text, age integer)\"; public MySQLiteOpenHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); this.context = context; this.name = name; } @Override public void onCreate(SQLiteDatabase db) { // 创建数据库表 db.execSQL(bookSql); db.execSQL(userSql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { db.execSQL(\"drop table if exists Book\"); db.execSQL(\"drop table if exists User\"); onCreate(db); // 重新执行一下onCreate方法 } } // 获取db对象 mySQLiteOpenHelper = new MySQLiteOpenHelper(getApplicationContext(), \"BookDatabase.db\", null, 3); SQLiteDatabase db= mySQLiteOpenHelper.getWritableDatabase(); // CRUD db.insert(\"Book\", null, values); 2. Kotlin中的数据库操作 虽然在Kotlin中也可以像上面的那种方式一样来进行数据库的操作，但是Google推出了一款数据库框架，即：Room。下面就使用这个框架进行完成操作。 2.1 依赖 首先需要添加依赖： // Room def room_version = \"2.2.6\" implementation \"androidx.room:room-runtime:$room_version\" // For Kotlin use kapt instead of annotationProcessor (注意这个注释) kapt \"androidx.room:room-compiler:$room_version\" implementation \"androidx.room:room-ktx:$room_version\" testImplementation \"androidx.room:room-testing:$room_version\" 当然，这里在kotlin中使用kapt，我们需要导入这个插件： plugins { id 'com.android.application' id 'kotlin-android' id 'kotlin-kapt' } 注释：如果项目是使用Kotlin语言来开发的，在添加room-compiler的时候使用kapt关键字，java语言开发的就使用annotationProcessor关键字。 2.2 基础概念 要想使用Room，必须要了解最基础的三个概念： Entity：实体类，对应的是数据库的一张表结构。需要使用注解 @Entity 标记。默认实体类的类名为表名，字段名为数据库中的字段。 Dao：包含访问一系列访问数据库的方法。需要使用注解 @Dao 标记。 Database：数据库持有者，作为与应用持久化相关数据的底层连接的主要接入点。需要使用注解 @Database 标记。 使用@Database注解需满足以下条件： 定义的类必须是一个继承于RoomDatabase的抽象类。 在注解中需要定义与数据库相关联的实体类列表。 包含一个没有参数的抽象方法并且返回一个带有注解的 @Dao。 注释：以上基础概念摘自：Jetpack架构组件 — Room入坑详解 2.2 1 @Entity 从前面我们知道，@Entity作用在类上，该类对应数据库中的一个数据表。属性对应数据库中的字段，那么类似的我们可以指定主键和注释。同样也是使用注解： @PrimaryKey注解用来标注表的主键，可以使用autoGenerate = true来指定了主键自增长； @ColumnInfo注解用来标注表对应的列的信息比如表名、默认值等等。 @Ignore 注解顾名思义就是忽略这个字段，使用了这个注解的字段将不会在数据库中生成对应的列信息。 2.2.2 @Dao Dao类是一个接口，其中定义了一系列的操作数据库的方法。Room也为我们的提供了相关的注解，有@Insert、@Delete、@Update 和 @Query。 比如： @Query(\"select * from user where userId = :id\") fun getUserById(id: Long): User 2.2.3 @Database 首先需要定义一个类，继承自RoomDatabase，并添加注解 @Database 来标识。 2.3 实战 这里我们需要一个数据库来存储用户记事本的数据，大致包括如下内容： | 字段 | 说明 | | --- | --- | | title | 标题 | | content | 数据内容 | | firstSubmit | 首次提交时间 | | lastModifiy | 最后一次修改时间 | | type | 类型，普通记事或者待办 | | label | 标签，支持多个，使用#号分割 | | category | 分类，工作/学习/生活/... | | groupId | 组号，默认为1，表示单个记录；如果为多个，表示前端显示为重叠 | 那么首先我们需要使用@Entity注解来生成逻辑的表（MFNote）： @Entity class MFNote { @PrimaryKey(autoGenerate = true) var noteId: Int = 0 @ColumnInfo(defaultValue = \"无标题\") lateinit var title: String @ColumnInfo(defaultValue = \"\") lateinit var content: String @ColumnInfo(name = \"first_submit\") var submit: String? = null @ColumnInfo(name = \"last_modify\") var modify: String? = null var type: Int = 0 @ColumnInfo(defaultValue = \"默认\") lateinit var label: String @ColumnInfo(defaultValue = \"默认\") lateinit var category: String @ColumnInfo(name = \"group_id\") var groupId: Int = 1 } 然后构建一个访问MFNote表的DAO接口（MFDao）： @Dao interface MFDao { @Insert(onConflict = OnConflictStrategy.REPLACE) fun insert(mfNote: MFNote?) @Delete fun delete(mfNote: MFNote): Int @Query(\"select * from MFNote\") fun getAllNotes(): List @Query(\"select * from MFNote where type = :type\") fun getNotesByType(type: Int): MFNote @Update fun updateNoteByNote(mfNote: MFNote) } 参数onConflict，表示的是当插入的数据已经存在时候的处理逻辑，有三种操作逻辑：REPLACE、ABORT和IGNORE。如果不指定则默认为ABORT终止插入数据。这里我们将其指定为REPLACE替换原有数据。 最后需要构建Room使用的入口RoomDatabase。 @Database(entities = [MFNote::class], version = 1) abstract class MFNoteDataBase : RoomDatabase() { abstract fun mfDao(): MFDao companion object { @Volatile private var mInstance: MFNoteDataBase? = null private const val DATABASE_NAME = \"MFNote.db\" @JvmStatic fun getInstance(context: Context): MFNoteDataBase? { if (mInstance == null) { synchronized(MFNoteDataBase::class.java) { if (mInstance == null) { mInstance = createInstance(context) } } } return mInstance } private fun createInstance(context: Context): MFNoteDataBase { mInstance = Room.databaseBuilder( context.applicationContext, MFNoteDataBase::class.java, DATABASE_NAME ).build() return mInstance as MFNoteDataBase } } } 在这里我们只需要对一个数据库表进行操作，所以就定义了一个抽象接口。如果需要定义多个，比如下面的写法： @Database(entities = [User::class, Course::class, Teacher::class, UserJoinCourse::class, IDCard::class], version = 1) abstract class AppDataBase : RoomDatabase() { abstract fun userDao(): UserDao abstract fun teacherDao(): TeacherDao abstract fun courseDao(): CourseDao abstract fun userJoinCourseDao(): UserJoinCourseDao abstract fun idCardDao(): IDCardDao } @Database 表示继承自RoomDatabase的抽象类，entities指定表的实现类列表，version指定了DB版本 必须提供获取DAO接口的抽象方法，比如上面定义的movieDao()，Room将通过这个方法实例化DAO接口 接下来就是调用了： class TestActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_test) // 调用Room数据库 val mfDao = MFNoteDataBase.getInstance(this)?.mfDao() mfDao?.insert(MFNote()) mfDao?.getAllNotes()?.forEach { Log.e(\"TAG\", \"onCreate: ${it.title}, ${it.category}\" ) } } } 结果： 最终我在Dao层添加了如下方法： @Dao interface MFDao { @Insert(onConflict = OnConflictStrategy.REPLACE) fun insert(mfNote: MFNote?) @Delete fun delete(mfNote: MFNote): Int @Query(\"select * from MFNote\") fun getAllNotes(): List @Query(\"select * from MFNote where noteId = :id\") fun getNoteByNoteId(id: Int): MFNote @Query(\"select * from MFNote where type = :type\") fun getNotesByType(type: Int): List @Query(\"select * from MFNote where label like '%' || :label || '%'\") fun getNotesByLabel(label: String): List @Query(\"select * from MFNote where category like '%' || :category || '%'\") fun getNotesByCategory(category: String): List @Query(\"select * from MFNote where group_id = :groupId\") fun getNotesByGroupId(groupId: Int): List @Query(\"select * from MFNote where first_submit >= :beginTime and first_submit @Query(\"select * from MFNote where first_submit >= :beginTime\") fun getNotesByStartSubmitTime(beginTime: String): List @Query(\"select * from MFNote where first_submit @Query(\"select * from MFNote where last_modify >= :beginTime and last_modify @Query(\"select * from MFNote where last_modify >= :beginTime\") fun getNotesByStartModifyTime(beginTime: String): List @Query(\"select * from MFNote where last_modify @Query(\"select * from MFNote where (title like '%' || :words || '%') or (content like '%' || :words || '%') or (first_submit like '%' || :words || '%') or (last_modify like '%' || :words || '%') or (label like '%' || :words || '%') or (category like '%' || :words || '%')\") fun getNodesByKeyWords(words: String): List @Update fun updateNoteByNote(mfNote: MFNote) } 测试代码： class TestActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_test) // 调用Room数据库 val mfDao = MFNoteDataBase.getInstance(this)?.mfDao() val mfNote = MFNote() mfNote.title = \"测试\" mfNote.content = \"第一条测试\" mfDao?.insert(mfNote) mfDao?.getAllNotes()?.forEach { Log.e(\"TAG\", \"onCreate: ${it.title}, ${it.category}\" ) } val notesByType = mfDao?.getNotesByType(0) notesByType?.forEach { Log.e(\"TAG\", \"onCreate: ${it.title}, ${it.category}\" ) } val entity = mfDao?.getNoteByNoteId(2) Log.e(\"TAG\", \"onCreate: ${entity?.title}, ${entity?.firstSubmit}\" ) entity?.title = \"厉害\" mfDao?.updateNoteByNote(entity!!) } } 以上代码均测试通过。 3. 数据库版本升级（Migration） 3.1 正常升级 数据库版本升级，也就是在原来的表中加入一些字段内容。在Room中提供了比较便捷的数据库升级方式。直接使用Migration来可以完成。甚至可以完成跳版本的升级，比如当前用户版本为1，而最新的版本为3，那么Room可以依次执行1-2-3的过程。比如此时我有一个表User，如下： 当然，对应的Room的使用这里不再介绍。此时的需求为在表中新增一个字段：nickName。那么可以在创建数据库的时候进行添加Migration： private fun createInstance(context: Context): UserDataBase { mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).addMigrations(Migration_1_2) // 数据库版本升级 .build() return mInstance as UserDataBase } // Migration(int startVersion, int endVersion) private val Migration_1_2 = object : Migration(1, 2) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\"alter TABLE User add column nickName TEXT default '123' not null\") } } 对应的，需要在@Entity注释的类中添加对应的字段： @ColumnInfo(name = \"nickName\", typeAffinity = ColumnInfo.TEXT) var nickname = \"\" 然后将之前的@Database注释的版本改为目标版本2： @Database(entities = arrayOf(User::class), version = 2, exportSchema = false) abstract class UserDataBase : RoomDatabase() 最后，就可以查看下数据库： 数据更新后的表： 当然，如果需要从版本1升级到版本3，就可以对应的定义: private val Migration_1_2 = object : Migration(1, 2) private val Migration_2_3 = object : Migration(2, 3) 以及在表中的字段定义好，然后在创建数据库的时候进行使用： mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).addMigrations(Migration_1_2, Migration_2_3) // 数据库版本升级 .build() 3.2 异常升级 参考文档：手动迁移 值得注意的是，有些时候可能敲错了，在@Database注解的参数中指定了一个不存在的版本，会导致程序的异常退出。比如此时我这里没有写2到3版本的升级Migration和添加对应的字段，当指定3后程序异常退出，报错为： Caused by: java.lang.IllegalStateException: A migration from 2 to 3 was required but not found. Please provide the necessary Migration path via RoomDatabase.Builder.addMigration(Migration ...) or allow for destructive migrations via one of the RoomDatabase.Builder.fallbackToDestructiveMigration* methods. 根据提示说明，知道要么添加一个新的Migration来指定添加的表字段，要么指定fallbackToDestructiveMigration方法。这里就添加一个fallbackToDestructiveMigration方法，即： mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).addMigrations(Migration_1_2) // 数据库版本升级 .fallbackToDestructiveMigration() .build() 最后，程序可以正常运行，但是用户数据库文件中的数据均会清空（破坏性地重新创建应用的数据库表，Room 在尝试执行没有定义迁移路径的迁移时会从数据库表中永久删除所有数据）。 3.3 Scheme文件 再次回顾一下@Database的注解： @Database(entities = arrayOf(User::class), version = 3, exportSchema = false) abstract class UserDataBase : RoomDatabase() 使用的时候，exportSchema指定为false，也就是不需要Schema文件。这里可以设置为true，然后在配置文件中指定一下生成的路径： android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments = [\"room.schemaLocation\": \"$projectDir/schemas\".toString()] } } } } 在项目路径下就可以看见生成的json文件： 导出的 JSON 文件代表数据库的架构历史记录。您应将这些文件存储在版本控制系统中，因为此系统允许Room 出于测试目的创建较旧版本的数据库。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"Livedata.html":{"url":"Livedata.html","title":"【Android Jetpack】Livedata","keywords":"","body":"[toc] 1. 前言 官网地址：https://developer.android.google.cn/topic/libraries/architecture/livedata 其实在使用ViewModel和LifeCycle的时候，我们已经看见了LiveData这个组件。在这篇博客中将继续来了解这个组件。其特点： LiveData是一种可观察的数据存储器类； 与常规的可观察类不同，LiveData具有生命周期感知能力。其感知能力遵循其他组件（如 Activity、Fragment 或 Service）的生命周期； 感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者；活跃的观察者对象声明周期处于STARTED或 RESUMED 状态； LiveData只会将更新通知给活跃的观察者，非活跃观察者不会收到更改通知； 当观察者组件的Lifecycle对象的状态变为 DESTROYED 时，便可移除此观察者，不必担心泄露（当 Activity和Fragment的生命周期被销毁时，系统会立即退订它们）。 不妨再次看下这个图： 1.1 关于观察者模式 我们知道观察者模式，在Java中提供了Observable和Observer来定义被观察者和观察者对象。然后对于可观察对象可以设置观察者，来监听其变化。而在Android的Lifecycle包中提供了对应的LifecycleOwner和LifecycleObserver，而在Activity、Fragment 或 Service等组件中已经实现了LifecycleOwner接口，我们在使用的时候，只需要实现LifecycleObserver来标识类是一个观察者，以注册观察。在之前的博客：【Android Jetpack】LifeCycle一文中也曾提到过通过： lifecycle.addObserver(myLocationObserver) 来为lifecycle来设置一个观察者对象。类似的，前面提到了：LiveData也是一种可观察的数据存储器类。故而也可以设置观察对象，比如： // viewModel.get() 获取的为LiveData对象 viewModel.get().observe(this, object : androidx.lifecycle.Observer{ override fun onChanged(value: Int?) { livedataText.text = viewModel.getValue().toString() } }) 2. LiveData 的优势 确保界面符合数据状态；LiveData 遵循观察者模式。当底层数据发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中更新界面。 不会发生内存泄漏；观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。 不会因 Activity 停止而导致崩溃；如果观察者的生命周期处于非活跃状态，则它不会接收任何 LiveData 事件。 不再需要手动处理生命周期； 共享资源；可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。 更加通俗来说，LiveData是一个持有Activity、Fragment生命周期的数据容器。当数据源发生改变的时候，可以通知观察者。 2.1 案例一：计时器效果 在Activity中定义一个文本，在该控件上每秒自动加一操作。且屏蔽设备配置发生改变后不影响其状态。比如布局文件为ConstraintLayout下放置一个居中的TextView。 2.1.1 实现方式一：ViewModel+LiveData 因为需要屏蔽设备配置发生改变的影响，故而这里考虑直接使用ViewModel； 考虑代码解耦，这里使用LiveData来设置观察者，也即是我们需要在ViewModel中设置数据类型为LiveData； 自定义的ViewModel如下： class MyNumberViewModel : ViewModel() { private var number: MutableLiveData = MutableLiveData(0) fun set(value: Int) { number.value = value } // 工作线程需要使用Post fun post(value: Int) { number.postValue(value) } fun get(): LiveData { return number } fun getValue(): Int{ return number.value?:0 } } 因为我们需要使用LiveData对象来注册观察者对象，故而这里get()方法返回的是LiveData对象。且因为需要开启定时任务，故而可以在工作线程完成，所以提供了post方法，然后在Activity中进行设置： class LiveDataActivity : AppCompatActivity() { private lateinit var viewModel: MyNumberViewModel private val livedataText: TextView by lazy { findViewById(R.id.livedata_text)} override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_live_data) // 获取到ViewModel viewModel = ViewModelProvider( this, ViewModelProvider.NewInstanceFactory() ).get(MyNumberViewModel::class.java) // 为TextView设置数据 livedataText.text = viewModel.get().toString() // 开始定时任务 startTimer() // 注册一个观察者，监听到ViewModel中数据的变化，如果变化执行onChanged()方法 // viewModel.get() 获取的为LiveData对象 viewModel.get().observe(this, object : androidx.lifecycle.Observer{ override fun onChanged(value: Int?) { livedataText.text = viewModel.getValue().toString() } }) } // 定时任务 private fun startTimer(){ Timer().schedule( object : TimerTask() { override fun run() { viewModel.post(viewModel.getValue() + 1) } }, 1000, 1000, ) } } 运行即可看见预想的效果。看完上述案例代码之后是否会有疑惑？肯定是有的，因为这里是LiveData的案例，却引入了ViewModel，且将LiveData放入了自定义的ViewModel类中，为什么需要这么做？LiveData对象本身就可以被观察，为什么还需要放置到ViewModel中？ 答：其实在刚开始的要求部分我已经做了引导，需要做到屏蔽设备配置发生改变后不影响其状态，而很方便的ViewModel就可以轻松做到这一点。如果LiveData实例与特定的 Activity 或 Fragment 实例并没有分离开，那么在 Activity 或 Fragment 经历onDestory的时候，LiveData中的数据也就没了。 且上述程序存在一个致命Bug，由于每次屏幕旋转都会执行onCreate，故而会开启多个定时任务，故而这里是不符合题意的。当然，可以加上标志处理，这里不再解决。 2.1.2 实现方式二：configChange 当然，上述使用ViewModel只是一种方式，也可以配置清单文件，设置onConfigChange属性，这里来尝试写一下： 然后将LiveData直接定义在Activity中： class LiveDataActivity : AppCompatActivity() { private val livedataText: TextView by lazy { findViewById(R.id.livedata_text) } private val liveData: MutableLiveData by lazy { MutableLiveData(0) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_live_data) // 为TextView设置数据 livedataText.text = liveData.value.toString() // 开始定时任务 startTimer() // 注册一个观察者，监听到ViewModel中数据的变化，如果变化执行onChanged()方法 // viewModel.get() 获取的为LiveData对象 liveData.observe(this) { livedataText.text = liveData.value.toString() } } override fun onConfigurationChanged(newConfig: Configuration) { super.onConfigurationChanged(newConfig) Log.e(\"TAG\", \"onConfigurationChanged: \") } // 定时任务 private fun startTimer() { Timer().schedule( object : TimerTask() { override fun run() { liveData.postValue((liveData.value ?: 0) + 1) Log.e(\"TAG\", \"run: ${liveData.value ?: 0}\", ) } }, 1000, 1000, ) } } 2.2 案例二： Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"【AndroidJetpack】Room+ViewModel+LiveData.html":{"url":"【AndroidJetpack】Room+ViewModel+LiveData.html","title":"【Android Jetpack】Room+ViewModel+LiveData","keywords":"","body":"[toc] 1. 前言 实现内容： 使用Room框架来完成数据库的CRUD操作； 对于查询到的数据库数据，使用LiveData进行封装，使得每次数据库中数据更新后都可以自动渲染到RecyclerView控件； 2. 实现 最后效果： 文件结构： 2.1 定义Room相关的结构 User表： @Entity(tableName = \"User\") class User { @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"userId\", typeAffinity = ColumnInfo.INTEGER) var id = 0 @ColumnInfo(name = \"userName\", typeAffinity = ColumnInfo.TEXT) var name = \"\" @ColumnInfo(name = \"userAge\", typeAffinity = ColumnInfo.INTEGER) var age = 10 // 可以让创建的时候忽略这个属性 @Ignore var date = \"2022年4月20日20:59:20\" } 使用@Entity注解标识表，使用tableName可以定制表名。@ColumnInfo来指定字段，typeAffinity用于指定该字段在数据库中的类型。最后的@Ignore标签可以用来忽略不需要加入到表中的数据。 同样可以在应用目录下找到这个数据库文件。不妨使用SQLiteStudio打开这个数据库文件： 可以看见确实@Ignore标签修饰的字段没有生成。 其实和SQLite差不多，只是做了一层封装。使得使用起来更简洁。 然后就是定义对应的接口操作层，有点类似于SpringBoot中常写的Service层： @Dao // 这个注解仅用作标识 interface UserDao { @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertUser(user: User): Unit @Delete fun deleteUser(user: User): Unit @Query(\"select * from User\") fun getAllUser(): LiveData> @Query(\"select * from User where userId = :userId\") fun getUserById(userId: Int): User @Update(onConflict = OnConflictStrategy.REPLACE) fun updateUser(user: User) } 上面值得注意的是其中一个方法，即： @Query(\"select * from User\") fun getAllUser(): LiveData> 在返回的数据List可以直接使用LiveData来进行包起来。最后是获取数据库实例的类，这个类定义为单例，所有的数据库中表相关的Dao层不需要实现，声明为抽象方法，具体的实现由Room自动实现，所以这个类也需要声明为abstract： @Database(entities = arrayOf(User::class), version = 1, exportSchema = false) abstract class UserDataBase : RoomDatabase() { // 定义的抽象方法，由Room自动实现，我们不需要实现 abstract fun userDao(): UserDao companion object { // 单例模式 private var mInstance: UserDataBase? = null private const val DATABASE_NAME = \"User.db\" @JvmStatic fun getInstance(context: Context): UserDataBase? { if (mInstance == null) { synchronized(UserDataBase::class.java) { if (mInstance == null) { mInstance = createInstance(context) } } } return mInstance } private fun createInstance(context: Context): UserDataBase { mInstance = Room.databaseBuilder( context.applicationContext, UserDataBase::class.java, DATABASE_NAME ).build() return mInstance as UserDataBase } } } 1.2 定义Repository 然后定义一层Repository，类似于SpringBoot中的Controller层。添加这一层主要是因为在Room要求数据操作不能在UI线程中，需要在子线程中进行操作。且在这个类中完成获取数据库的实例对象，然后再次封装CRUD方法，可以在自定义ViewModel的类中更加简洁。 /** * @author 梦否 on 2022/4/20 * @blog https://mengfou.blog.csdn.net/ */ class UserRepository(var context: Context) { private var userDao: UserDao? = null init { // 获取到数据库操作的Dao层接口 userDao = UserDataBase.getInstance(context)?.userDao() } // Android-Room要求数据操作不能在UI线程中，需要在子线程中进行操作 fun insertUser(user: User) { GlobalScope.launch { userDao?.insertUser(user) } } fun deleteUserById(id: Int) { val user = User().apply { this.id = id } GlobalScope.launch { userDao?.deleteUser(user) } } fun updateUser(user:User){ GlobalScope.launch { userDao?.updateUser(user) } } fun getAllUsers(): LiveData>? { return userDao?.getAllUser() } } 1.3 定义ViewModel 最后在ViewModel中共只需要完成获取所有数据即可。因为返回的是LiveData所以我们可以设置监听： class UserViewModel() : ViewModel() { var repository: UserRepository? = null var context: Context? = null fun getUsers(): LiveData>? { val allUsers = repository?.getAllUsers() return allUsers } } 1.4 定义RecyclerView 在布局文件中，因为需要使用RecyclerView来渲染数据，所以这里首先定义一个适配器类，且在这个控件需要完成数据库中数据发生改变后就自动渲染。所以这里使用dataBinding来定义布局文件： 然后定义对应的适配器： class MyRecyclerViewAdapter(val context: Context, var datas: List) : RecyclerView.Adapter() { fun setData(datas: List) { this.datas = datas } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder { val binding = DataBindingUtil.inflate( LayoutInflater.from(context), R.layout.room_recyclerview_item, parent, false ) val myViewHolder = MyViewHolder(binding.root).apply { this.binding = binding } return myViewHolder } override fun onBindViewHolder(holder: MyViewHolder, position: Int) { datas.apply { holder.binding?.user = datas.get(position) } } override fun getItemCount(): Int { return datas.size } inner class MyViewHolder(view: View) : RecyclerView.ViewHolder(view) { var binding: RoomRecyclerviewItemBinding? = null } } 1.5 定义Activity 最后就是在Activity中进行使用了： class MainActivity : AppCompatActivity() { private val userRepository: UserRepository by lazy { val userRepository = UserRepository(this) userRepository } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView( this, R.layout.activity_main2 ) val myViewModel = ViewModelProvider(this, ViewModelProvider.NewInstanceFactory()) .get(UserViewModel::class.java) myViewModel.context = this myViewModel.repository = userRepository val myRecyclerViewAdapter = MyRecyclerViewAdapter(this, userRepository.getAllUsers()?.value ?: ArrayList()) binding.recycleview.layoutManager = LinearLayoutManager(this) binding.recycleview.adapter = myRecyclerViewAdapter myViewModel.getUsers()?.observe(this) { myRecyclerViewAdapter.datas = it myRecyclerViewAdapter.notifyDataSetChanged() currentDatas = it } } private var count = 1 private var currentDatas: List? = null fun insert(view: View) { userRepository.insertUser(User().apply { name = \"张${ count++ }\" age = 20 }) } fun delete(view: View) { // 随机删除一个 currentDatas?.let { if(currentDatas!!.isNotEmpty()) { val index = (Math.random() * currentDatas!!.size).toInt() currentDatas?.get(index)?.id?.let { userRepository.deleteUserById(it) } } } } fun update(view: View) { currentDatas?.let { if(currentDatas!!.isNotEmpty()) { // 随机修改一个用户信息 val index = (Math.random() * currentDatas!!.size).toInt() currentDatas?.get(index)?.apply { name = \"update: ${ name }\" userRepository.updateUser(this) } } } } } 至于主布局文件，比较简单这里不再给出。 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"【AndroidJetpack】Room——其余.html":{"url":"【AndroidJetpack】Room——其余.html","title":"【Android Jetpack】Room——其余","keywords":"","body":"[toc] 1. 前言 在前面两篇博客中介绍了Room的一些用法，简单了解了Room的使用。在这篇博客中，将继续对Room进行介绍。 2. Room总结 参考文档：Room Room是在SQLite上的一个层封装； 简化了传统使用SQLiteOpenHelper方式的复杂性，注解操作更加便捷； 数据库迁移更加方便，且能够记录每个版本的数据库表构成（json文件）； 其内三个最基础的组件为@Entity、@Dao、@Database，分别对应表、操作接口和数据库对象（抽象类）。这里不再重复介绍，可以查看博客：【Android Jetpack】Room 对于数据库实例化对象，需要遵循单例模式，在kotlin中需要使用@JvmStatic来进行标识，且对于每个表（即@Entity标识的类）的Dao接口需要申明，不需要实现。具体的实现由Room框架完成，也就是数据库实例化对象的类文件也为抽象类。对应的核心创建方法为： val db = Room.databaseBuilder( applicationContext, AppDatabase::class.java, \"database-name\" ).build() 2.1 复合主键 即使用多个列的组合对实体实例进行唯一标识，比如下面的案例： @Entity(primaryKeys = [\"firstName\", \"lastName\"]) data class User( val firstName: String?, val lastName: String? ) 2.2 忽略字段 在【Android Jetpack】Room一文中也提到过，可以使用@Ignore来忽略一些字段。 2.3 索引 我们知道在数据库表中，可以将数据库中的某些列编入索引，以加快查询速度。故而在创建表的时候，可以指定索引。比如下面的案例： @Entity(indices = [Index(value = [\"last_name\", \"address\"])]) data class User( val address: String?, @ColumnInfo(name = \"last_name\") val lastName: String?, @Ignore val picture: Bitmap? ) 2.4 SQL传递参数 2.4.1 简单参数 其实在前面的文章中我们都使用过，这里再次回顾一下，比如下面的案例： @Query(\"SELECT * FROM user WHERE age > :minAge\") fun loadAllUsersOlderThan(minAge: Int): Array 在注解@Query的参数中，这里传递参数使用:，比如:minAge。 2.4.2 集合参数 当然，有些时候需要使用集合类型的参数，比如下面的案例： @Query(\"SELECT * FROM user WHERE region IN (:regions)\") fun loadUsersFromRegions(regions: List): List 2.5 多表查询 2.5.1 普通条件查询 其实也就是SQL语句中的多表查询，比如： @Query( \"SELECT * FROM book \" + \"INNER JOIN loan ON loan.book_id = book.id \" + \"INNER JOIN user ON user.id = loan.user_id \" + \"WHERE user.name LIKE :userName\" ) fun findBooksBorrowedByNameSync(userName: String): List 2.5.2 联合查询 比如下面的案例，在SQL语句中返回的是user表和book的笛卡尔积表结果： @Query( \"SELECT * FROM user\" + \"JOIN book ON user.id = book.user_id\" ) fun loadUserAndBookNames(): Map> 返回值类型也值得注意，为Map>。当然还可以使用条件过滤，比如： @Query( \"SELECT * FROM user\" + \"JOIN book ON user.id = book.user_id\" + \"GROUP BY user.name WHERE COUNT(book.id) >= 3\" ) fun loadUserAndBookNames(): Map> Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "},"【AndroidJetpack】Room——对象之间的关系.html":{"url":"【AndroidJetpack】Room——对象之间的关系.html","title":"【Android Jetpack】Room——多表之间的关系","keywords":"","body":"[toc] 1. 前言 在这篇博客中，介绍一下定义数据库表的时候的多种关系。参考文档地址：定义对象之间的关系 2. 多表关系 2.1 基本嵌套 在OOP的思想中，万物均对象。故而在创建用户类的时候，下面的写法并不陌生： data class Address( val street: String?, val state: String?, val city: String?, @ColumnInfo(name = \"post_code\") val postCode: Int ) @Entity data class User( @PrimaryKey val id: Int, val firstName: String?, @Embedded val address: Address? ) 注意在嵌套的时候，所使用的注解为@Embedded。执行完毕后，可以得到包含id、firstName、street、state、city和post_code的User表结构。 2.2 定义嵌套一对一关系 比如定义了两个表，为User和Library类。如下： @Entity data class User( @PrimaryKey val userId: Long, val name: String, val age: Int ) @Entity data class Library( @PrimaryKey val libraryId: Long, val userOwnerId: Long ) 注意到，在Library类中使用了userOwnerId来表示用户，对应User表中的userId字段，这里可以认为为外键关系，为了表示这种关系，可以再定义一个类，用@Relation注解来标识这种一对一关系。如下： data class UserAndLibrary( @Embedded val user: User, @Relation( parentColumn = \"userId\", entityColumn = \"userOwnerId\" ) val library: Library ) 将@Relation注释添加到子实体的实例，同时将parentColumn设置为父实体主键列的名称，并将entityColumn设置为引用父实体主键的子实体列的名称。最后，向 DAO 类添加一个方法，用于返回将父实体与子实体配对的数据类的所有实例。该方法需要 Room运行两次查询，因此应向该方法添加@Transaction注释，以确保整个操作以原子方式执行。 @Transaction @Query(\"SELECT * FROM User\") fun getUsersAndLibraries(): List 3. 案例 3.1 一对一关系 Copyright © 梦否 2022 all right reserved，powered by Gitbook最后更新时间： 2022-04-26 18:31:38 "}}